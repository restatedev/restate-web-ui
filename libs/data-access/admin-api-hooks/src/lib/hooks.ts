import type {
  components,
  JournalEntryV2,
  operations,
} from '@restate/data-access/admin-api/spec'; // generated by openapi-typescript
import {
  MutationOptions,
  Query,
  useMutation,
  UseMutationOptions,
  useQueries,
  useQuery,
  useQueryClient,
  UseQueryResult,
} from '@tanstack/react-query';
import { adminApi, OperationParameters } from '@restate/data-access/admin-api';
import { useAdminBaseUrl } from '@restate/data-access/admin-api';
import type {
  DeploymentId,
  Revision,
  ServiceName,
  Deployment,
  FilterItem,
  Service,
  StateResponse,
  HookQueryOptions,
  HookMutationOptions,
} from '@restate/data-access/admin-api';
import { useCallback, useMemo } from 'react';
import { RestateError } from '@restate/util/errors';
import { useAPIStatus } from '@restate/data-access/admin-api';
import { useRestateContext } from '@restate/features/restate-context';
import { base64ToUint8Array } from '@restate/util/binary';

const SERVICE_TIMESTAMP = new Map<string, Date>();

function listDeploymentsSelector(
  data:
    | {
        deployments: components['schemas']['DeploymentResponse'][];
      }
    | undefined,
) {
  if (!data) {
    return undefined;
  }

  const { deployments: deploymentsFromApi } = data;

  const services = new Map<
    ServiceName,
    {
      deployments: Record<Revision, DeploymentId[]>;
      sortedRevisions: number[];
      revisionsSet: Set<number>;
    }
  >();
  const deployments = new Map<DeploymentId, Deployment>();

  for (const deployment of deploymentsFromApi) {
    deployments.set(deployment.id, deployment);

    for (const service of deployment.services) {
      let serviceData = services.get(service.name);

      if (!serviceData) {
        serviceData = {
          deployments: {},
          sortedRevisions: [],
          revisionsSet: new Set<number>(),
        };
        services.set(service.name, serviceData);
      }

      serviceData.revisionsSet.add(service.revision);

      if (!serviceData.deployments[service.revision]) {
        serviceData.deployments[service.revision] = [];
      }
      serviceData.deployments[service.revision]?.push(deployment.id);
    }
  }

  for (const [serviceName, serviceData] of services) {
    serviceData.sortedRevisions = Array.from(serviceData.revisionsSet).sort(
      (a, b) => b - a,
    );

    if (!SERVICE_TIMESTAMP.has(serviceName)) {
      const latestRevision = serviceData.sortedRevisions[0];
      const deploymentId = latestRevision
        ? serviceData.deployments[latestRevision]?.[0]
        : undefined;
      const deployment = deploymentId
        ? deployments.get(deploymentId)
        : undefined;
      const timestamp = deployment?.created_at || Date.now();
      SERVICE_TIMESTAMP.set(serviceName, new Date(timestamp));
    }
  }

  const sortedServiceNames = Array.from(services.keys()).sort((a, b) => {
    const bTimestamp = SERVICE_TIMESTAMP.get(b);
    const aTimestamp = SERVICE_TIMESTAMP.get(a);
    if (!aTimestamp || !bTimestamp) {
      return a.localeCompare(b);
    }
    return bTimestamp.getTime() - aTimestamp.getTime() || a.localeCompare(b);
  });

  return { services, deployments, sortedServiceNames };
}

export function useListDeployments(
  options?: HookQueryOptions<'/deployments', 'get'>,
) {
  const enabled = useAPIStatus();

  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/deployments', 'get', { baseUrl });

  const results = useQuery({
    ...queryOptions,
    ...options,
    select: listDeploymentsSelector,
    enabled: options?.enabled !== false && enabled,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
    isPending: results.isPending || !enabled,
  };
}

export function useSqlQuery(
  query: string,
  options?: HookQueryOptions<'/query', 'post'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/query', 'post', {
    baseUrl,
    body: { query },
  });

  const results = useQuery({
    ...queryOptions,
    ...options,
    enabled: Boolean(query),
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function isVersionQuery(
  data: unknown,
  query: Query<unknown, unknown, unknown>,
): data is components['schemas']['VersionInformation'] {
  const { queryKey } = query;
  return Array.isArray(queryKey) && queryKey[0] === '/version';
}

export function isListDeployments(
  data: unknown,
  query: Query<unknown, unknown, unknown>,
): data is components['schemas']['ListDeploymentsResponse'] {
  const { queryKey, meta } = query;
  return (
    Array.isArray(queryKey) &&
    queryKey[0] === '/deployments' &&
    meta?.['method'] === 'get'
  );
}

export function isListInvocations(
  data: unknown,
  query: Query<unknown, Error, unknown, readonly unknown[]>,
): data is operations['list_invocations']['responses']['200']['content']['application/json'] {
  const { queryKey, meta } = query;
  return (
    Array.isArray(queryKey) &&
    queryKey[0] === '/query/invocations' &&
    meta?.['method'] === 'post'
  );
}

export function isGetInvocationJournalWithInvocationV2(
  data: unknown,
  query: Query<unknown, unknown, unknown>,
): data is operations['get_invocation_journal_v2']['responses']['200']['content']['application/json'] {
  const { queryKey, meta } = query;
  return (
    Array.isArray(queryKey) &&
    queryKey[0] === '/query/v2/invocations/{invocationId}' &&
    meta?.['method'] === 'get'
  );
}

export function useRegisterDeployment(
  options?: Omit<
    HookMutationOptions<'/deployments', 'post'>,
    'mutationFn' | 'mutationKey' | 'onSettled'
  > & { retryWithHttp1?: boolean },
) {
  const baseUrl = useAdminBaseUrl();
  const { onSuccess, retryWithHttp1, ...rest } = options ?? {};
  const queryCLient = useQueryClient();
  const mutationOptions = adminApi('mutate', '/deployments', 'post', {
    baseUrl,
  });

  const { mutationFn: _mutationFn, meta } = mutationOptions;
  const mutationFn: typeof mutationOptions.mutationFn = useCallback(
    async (args, context) => {
      return _mutationFn(args, context).catch(async (originalError) => {
        if (
          retryWithHttp1 &&
          args.body &&
          args.body.dry_run &&
          'uri' in args.body
        ) {
          try {
            await _mutationFn(
              {
                ...args,
                body: {
                  ...args.body,
                  use_http_11: true,
                },
              },
              { client: queryCLient, meta },
            );
            throw new RestateError(
              'Service discovery response failed, and the server may have responded in HTTP1.1.',
              'META0014',
            );
          } catch (_) {
            throw originalError;
          }
        }
        throw originalError;
      });
    },
    [_mutationFn, meta, queryCLient, retryWithHttp1],
  );

  return useMutation({
    ...mutationOptions,
    ...rest,
    mutationFn,
    onSuccess(data, variables, context, meta) {
      if (!variables.body?.dry_run) {
        data?.services.forEach((service) => {
          const serviceName = service.name;
          const { queryKey } = getServiceAdminApi({
            baseUrl,
            parameters: { path: { service: serviceName } },
          });
          queryCLient.invalidateQueries({
            queryKey,
          });
        });
      }
      return onSuccess?.(data, variables, context, meta);
    },
  });
}

export function useUpdateDeployment(
  deployment: string,
  options?: Omit<
    HookMutationOptions<'/deployments/{deployment}', 'patch'>,
    'mutationFn' | 'mutationKey' | 'onSettled'
  > & { retryWithHttp1?: boolean },
) {
  const baseUrl = useAdminBaseUrl();
  const { onSuccess, retryWithHttp1, ...rest } = options ?? {};
  const queryCLient = useQueryClient();
  const mutationOptions = adminApi(
    'mutate',
    '/deployments/{deployment}',
    'patch',
    {
      baseUrl,
      resolvedPath: `/deployments/${deployment}`,
    },
  );

  const { mutationFn: _mutationFn, meta } = mutationOptions;
  const mutationFn: typeof mutationOptions.mutationFn = useCallback(
    async (args, context) => {
      return _mutationFn(
        {
          ...args,
          parameters: {
            path: {
              deployment,
            },
          },
        },
        context,
      ).catch(async (originalError) => {
        if (
          retryWithHttp1 &&
          args.body &&
          args.body.dry_run &&
          'uri' in args.body
        ) {
          try {
            await _mutationFn(
              {
                ...args,
                parameters: {
                  path: {
                    deployment,
                  },
                },
                body: {
                  ...args.body,
                  use_http_11: true,
                },
              },
              { client: queryCLient, meta },
            );
            throw new RestateError(
              'Service discovery response failed, and the server may have responded in HTTP1.1.',
              'META0014',
            );
          } catch (_) {
            throw originalError;
          }
        }
        throw originalError;
      });
    },
    [_mutationFn, meta, queryCLient, retryWithHttp1, deployment],
  );

  return useMutation({
    ...mutationOptions,
    ...rest,
    mutationFn,
    onSuccess(data, variables, context, meta) {
      if (!variables.body?.dry_run) {
        data?.services.forEach((service) => {
          const serviceName = service.name;
          const { queryKey } = getServiceAdminApi({
            baseUrl,
            parameters: { path: { service: serviceName } },
          });
          queryCLient.invalidateQueries({
            queryKey,
          });
        });
        queryCLient.invalidateQueries({
          queryKey: adminApi('query', '/deployments', 'get', { baseUrl })
            .queryKey,
        });
        queryCLient.invalidateQueries({
          queryKey: adminApi('query', '/deployments/{deployment}', 'get', {
            baseUrl,
            resolvedPath: `/deployments/${deployment}`,
            parameters: { path: { deployment } },
          }).queryKey,
        });
      }
      return onSuccess?.(data, variables, context, meta);
    },
  });
}

function getServiceAdminApi(init: {
  baseUrl: string;
  parameters?: OperationParameters<'/services/{service}', 'get'>;
  resolvedPath?: string;
}) {
  const { queryFn, ...queryOptions } = adminApi(
    'query',
    '/services/{service}',
    'get',
    init,
  );

  return {
    ...queryOptions,
    queryFn: (...args: Parameters<typeof queryFn>) =>
      Promise.resolve(queryFn(...args))?.then((data) => {
        if (!data) {
          return data;
        }
        return {
          ...data,
          handlers: data?.handlers.sort((a, b) => a.name.localeCompare(b.name)),
        };
      }),
  };
}

export function useServiceDetails(
  service: string,
  options?: HookQueryOptions<'/services/{service}', 'get'>,
) {
  const baseUrl = useAdminBaseUrl();
  const { queryFn, ...queryOptions } = getServiceAdminApi({
    baseUrl,
    parameters: { path: { service } },
  });

  const results = useQuery({
    staleTime: 0,
    ...queryOptions,
    queryFn: (...args: Parameters<typeof queryFn>) =>
      Promise.resolve(queryFn(...args))?.then((data) => {
        if (!data) {
          return data;
        }
        return {
          ...data,
          handlers: data?.handlers.sort((a, b) => a.name.localeCompare(b.name)),
        };
      }),
    ...options,
  });

  return { ...results, queryKey: queryOptions.queryKey };
}

export function useListServices(
  services: string[] = [],
  options?: HookQueryOptions<'/services/{service}', 'get'>,
) {
  const enabled = useAPIStatus();
  const baseUrl = useAdminBaseUrl();

  const results = useQueries({
    queries: services.map((service) => ({
      ...getServiceAdminApi({
        baseUrl,
        parameters: { path: { service } },
      }),
      staleTime: 0,
      ...options,
      enabled: options?.enabled !== false && enabled,
    })),
    combine: (results) => {
      return {
        data: results.reduce((result, service) => {
          if (service.data) {
            result.set(service.data?.name, service.data);
          }
          return result;
        }, new Map<string, Service>()),
        isPending: results.some((result) => result.isPending) || !enabled,
        promise: Promise.all(results.map(({ promise }) => promise)),
      };
    },
  });

  return results;
}

export function useDeploymentDetails(
  deployment: string,
  options?: HookQueryOptions<'/deployments/{deployment}', 'get'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/deployments/{deployment}', 'get', {
    baseUrl,
    resolvedPath: `/deployments/${deployment}`,
    parameters: { path: { deployment } },
  });

  const results = useQuery({
    staleTime: 0,
    ...queryOptions,
    ...options,
  });

  return { ...results, queryKey: queryOptions.queryKey };
}

export function useListSubscriptions(
  options?: HookQueryOptions<'/subscriptions', 'get'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/subscriptions', 'get', {
    baseUrl,
  });

  const results = useQuery({
    staleTime: 0,
    ...queryOptions,
    ...options,
  });

  return { ...results, queryKey: queryOptions.queryKey };
}

export function useCountInvocations(
  filters: FilterItem[],
  options?: HookQueryOptions<'/query/invocations/count', 'post'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/query/invocations/count', 'post', {
    baseUrl,
    body: {
      filters,
    },
  });

  const results = useQuery({
    staleTime: 0,
    ...queryOptions,
    ...options,
  });

  return { ...results, queryKey: queryOptions.queryKey };
}

export function useModifyService(
  service: string,
  options?: HookMutationOptions<'/services/{service}', 'patch'>,
) {
  const baseUrl = useAdminBaseUrl();

  return useMutation({
    ...adminApi('mutate', '/services/{service}', 'patch', {
      baseUrl,
      resolvedPath: `/services/${service}`,
    }),
    ...options,
  });
}

export function useDeleteDeployment(
  deployment: string,
  options?: HookMutationOptions<'/deployments/{deployment}', 'delete'>,
) {
  const baseUrl = useAdminBaseUrl();

  return useMutation({
    ...adminApi('mutate', '/deployments/{deployment}', 'delete', {
      baseUrl,
      resolvedPath: `/deployments/${deployment}`,
    }),
    ...options,
  });
}

export function useServiceOpenApi(
  service: string,
  options?: HookQueryOptions<'/services/{service}/openapi', 'get'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/services/{service}/openapi', 'get', {
    baseUrl,
    parameters: { path: { service } },
  });

  const results = useQuery({
    staleTime: 0,
    ...queryOptions,
    ...options,
  });

  return { ...results, queryKey: queryOptions.queryKey };
}

export function useListInvocations(
  body: components['schemas']['ListInvocationsRequestBody'],
  options?: HookQueryOptions<'/query/invocations', 'post'>,
) {
  const enabled = useAPIStatus();

  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/query/invocations', 'post', {
    baseUrl,
    body: body,
  });

  const results = useQuery({
    ...queryOptions,
    ...options,
    enabled: options?.enabled !== false && enabled,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
    isPending: results.isPending || !enabled,
  };
}

export function useGetInvocation(
  invocationId: string,
  options?: HookQueryOptions<'/query/invocations/{invocationId}', 'get'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/invocations/{invocationId}',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId } },
    },
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useGetInvocationJournal(
  invocationId: string,
  options?: HookQueryOptions<
    '/query/invocations/{invocationId}/journal',
    'get'
  >,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/invocations/{invocationId}/journal',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId } },
    },
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useGetInvocationJournalEntry(
  invocationId: string,
  entryIndex: number,
  options?: HookQueryOptions<
    '/query/invocations/{invocationId}/journal/{entryIndex}',
    'get'
  >,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/invocations/{invocationId}/journal/{entryIndex}',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId, entryIndex } },
    },
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useGetInvocationJournalWithInvocationV2(
  invocationId: string,
  options?: HookQueryOptions<'/query/v2/invocations/{invocationId}', 'get'>,
) {
  const baseUrl = useAdminBaseUrl();
  const query = adminApi(
    'query',
    '/query/v2/invocations/{invocationId}',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId }, query: { journal: true } },
    },
  );
  const results = useQuery({
    ...query,
    ...options,
  });

  return { queryKey: query.queryKey, ...results };
}

export function useGetInvocationsJournalWithInvocationsV2(
  invocationIds: string[],
  options?: HookQueryOptions<'/query/v2/invocations/{invocationId}', 'get'>,
) {
  const baseUrl = useAdminBaseUrl();
  const invocationQueries = useMemo(
    () =>
      invocationIds.map((invocationId) =>
        adminApi('query', '/query/v2/invocations/{invocationId}', 'get', {
          baseUrl,
          parameters: { path: { invocationId }, query: { journal: true } },
        }),
      ),
    [baseUrl, invocationIds],
  );

  const combine = useCallback(
    (
      results: UseQueryResult<
        | ReturnType<typeof useGetInvocationJournalWithInvocationV2>['data']
        | undefined,
        Error
      >[],
    ) => {
      return {
        data: invocationIds.reduce(
          (combined, invocationId, index) => {
            return {
              ...combined,
              [invocationId]: results.at(index)?.data,
            };
          },
          {} as Record<
            string,
            ReturnType<typeof useGetInvocationJournalWithInvocationV2>['data']
          >,
        ),
        isPending: invocationIds.reduce(
          (combined, invocationId, index) => {
            return {
              ...combined,
              [invocationId]: results.at(index)?.isPending,
            };
          },
          {} as Record<string, boolean | undefined>,
        ),
        isSuccess: invocationIds.reduce(
          (combined, invocationId, index) => {
            return {
              ...combined,
              [invocationId]: results.at(index)?.isSuccess,
            };
          },
          {} as Record<string, boolean | undefined>,
        ),
        error: invocationIds.reduce(
          (combined, invocationId, index) => {
            return {
              ...combined,
              [invocationId]: results.at(index)?.error,
            };
          },
          {} as Record<string, Error | null | undefined>,
        ),
        dataUpdatedAt: invocationIds.reduce(
          (combined, invocationId, index) => {
            return {
              ...combined,
              [invocationId]: results.at(index)?.dataUpdatedAt,
            };
          },
          {} as Record<string, number | undefined>,
        ),
      };
    },
    [invocationIds],
  );

  const results = useQueries({
    queries: [
      ...invocationQueries.map((invocationQuery) => ({
        ...invocationQuery,
        ...options,
        refetchOnMount: options?.refetchOnMount !== false,
        enabled: options?.enabled !== false,
        staleTime: 0,
      })),
    ],
    combine,
  });

  const queryClient = useQueryClient();

  const invalidate = useCallback(() => {
    return Promise.all([
      ...invocationQueries.map((invocationQuery) =>
        queryClient.invalidateQueries({
          queryKey: invocationQuery.queryKey,
        }),
      ),
    ]);
  }, [invocationQueries, queryClient]);

  return {
    ...results,
    refetch: () => {
      return Promise.all([
        ...invocationQueries.map((invocationQuery) =>
          queryClient.refetchQueries({
            queryKey: invocationQuery.queryKey,
          }),
        ),
      ]);
    },
    invalidate,
  };
}

export function useGetVirtualObjectQueue(
  serviceName: string,
  key: string,
  invocationId?: string,
  options?: HookQueryOptions<
    '/query/virtualObjects/{name}/keys/{key}/queue',
    'get'
  >,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/virtualObjects/{name}/keys/{key}/queue',
    'get',
    {
      baseUrl,
      parameters: { path: { key, name: serviceName }, query: { invocationId } },
    },
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useGetVirtualObjectState(
  serviceName: string,
  key: string,
  options?: HookQueryOptions<'/query/services/{name}/keys/{key}/state', 'get'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/services/{name}/keys/{key}/state',
    'get',
    {
      baseUrl,
      parameters: { path: { key, name: serviceName } },
    },
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useQueryVirtualObjectState(
  serviceName: string,
  filters?: FilterItem[],
  options?: HookQueryOptions<'/query/services/{name}/state/query', 'post'>,
) {
  const enabled = useAPIStatus();
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/services/{name}/state/query',
    'post',
    {
      baseUrl,
      parameters: { path: { name: serviceName } },
      body: {
        filters,
      },
      resolvedPath: `/query/services/${serviceName}/state/query`,
    },
  );
  const results = useQuery({
    ...queryOptions,
    ...options,
    enabled: options?.enabled !== false && enabled,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
    isPending: results.isPending || !enabled,
  };
}

export function useListVirtualObjectState(
  serviceName: string,
  keys: string[],
  options?: HookQueryOptions<'/query/services/{name}/state', 'post'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/services/{name}/state',
    'post',
    {
      baseUrl,
      parameters: { path: { name: serviceName } },
      body: {
        keys,
      },
      resolvedPath: `/query/services/${serviceName}/state`,
    },
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
    ...(keys.length === 0 && { enabled: false }),
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useKillInvocation(
  invocation_id: string,
  options?: HookMutationOptions<'/invocations/{invocation_id}/kill', 'patch'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryCLient = useQueryClient();

  return useMutation({
    ...adminApi('mutate', '/invocations/{invocation_id}/kill', 'patch', {
      baseUrl,
      resolvedPath: `/invocations/${invocation_id}/kill`,
    }),
    ...options,
    onSuccess(data, variables, context, meta) {
      options?.onSuccess?.(data, variables, context, meta);

      queryCLient.invalidateQueries({
        queryKey: adminApi(
          'query',
          '/query/v2/invocations/{invocationId}',
          'get',
          {
            baseUrl,
            parameters: {
              path: {
                invocationId: String(variables.parameters?.path.invocation_id),
              },
              query: { journal: true },
            },
          },
        ).queryKey,
      });
      queryCLient.invalidateQueries({
        predicate(query) {
          const queryKey = query.queryKey;
          if (
            Array.isArray(queryKey) &&
            queryKey.at(0) === '/query/invocations'
          ) {
            return true;
          }
          return false;
        },
      });
    },
  });
}

export function useCancelInvocation(
  invocation_id: string,
  options?: HookMutationOptions<'/invocations/{invocation_id}/cancel', 'patch'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryCLient = useQueryClient();

  return useMutation({
    ...adminApi('mutate', '/invocations/{invocation_id}/cancel', 'patch', {
      baseUrl,
      resolvedPath: `/invocations/${invocation_id}/cancel`,
    }),
    ...options,
    onSuccess(data, variables, context, meta) {
      options?.onSuccess?.(data, variables, context, meta);

      queryCLient.invalidateQueries({
        queryKey: adminApi(
          'query',
          '/query/v2/invocations/{invocationId}',
          'get',
          {
            baseUrl,
            parameters: {
              path: {
                invocationId: String(variables.parameters?.path.invocation_id),
              },
              query: { journal: true },
            },
          },
        ).queryKey,
      });
      queryCLient.invalidateQueries({
        predicate(query) {
          const queryKey = query.queryKey;
          if (
            Array.isArray(queryKey) &&
            queryKey.at(0) === '/query/invocations'
          ) {
            return true;
          }
          return false;
        },
      });
    },
  });
}

export function usePurgeInvocation(
  invocation_id: string,
  options?: HookMutationOptions<'/invocations/{invocation_id}/purge', 'patch'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryCLient = useQueryClient();

  return useMutation({
    ...adminApi('mutate', '/invocations/{invocation_id}/purge', 'patch', {
      baseUrl,
      resolvedPath: `/invocations/${invocation_id}/purge`,
    }),
    ...options,
    onSuccess(data, variables, context, meta) {
      options?.onSuccess?.(data, variables, context, meta);
      queryCLient.invalidateQueries({
        predicate(query) {
          const queryKey = query.queryKey;
          if (
            Array.isArray(queryKey) &&
            queryKey.at(0) === '/query/invocations'
          ) {
            return true;
          }
          return false;
        },
      });
    },
  });
}

export function usePauseInvocation(
  invocationId: string,
  options?: HookMutationOptions<'/invocations/{invocation_id}/pause', 'patch'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryCLient = useQueryClient();

  return useMutation({
    ...adminApi('mutate', '/invocations/{invocation_id}/pause', 'patch', {
      baseUrl,
      resolvedPath: `/invocations/${invocationId}/pause`,
    }),
    ...options,
    async onSuccess(data, variables, context, meta) {
      queryCLient.invalidateQueries({
        queryKey: adminApi(
          'query',
          '/query/v2/invocations/{invocationId}',
          'get',
          {
            baseUrl,
            parameters: {
              path: {
                invocationId: String(variables.parameters?.path.invocation_id),
              },
              query: { journal: true },
            },
          },
        ).queryKey,
      });
      queryCLient.invalidateQueries({
        predicate(query) {
          const queryKey = query.queryKey;
          if (
            Array.isArray(queryKey) &&
            queryKey.at(0) === '/query/invocations'
          ) {
            return true;
          }
          return false;
        },
      });
      options?.onSuccess?.(data, variables, context, meta);
    },
  });
}

export function useRestartInvocationAsNew(
  invocation_id: string,
  options?: HookMutationOptions<
    '/invocations/{invocation_id}/restart-as-new',
    'patch'
  >,
) {
  const baseUrl = useAdminBaseUrl();

  return useMutation({
    ...adminApi(
      'mutate',
      '/invocations/{invocation_id}/restart-as-new',
      'patch',
      {
        baseUrl,
        resolvedPath: `/invocations/${invocation_id}/restart-as-new`,
      },
    ),
    ...options,
  });
}

export function useRestartWorkflowAsNew(
  invocationId: string,
  options?: MutationOptions<
    {
      invocationId: string;
      status: string;
    },
    Error,
    {
      invocationId: string;
      workflowId: string;
    },
    unknown
  >,
) {
  const { ingressUrl } = useRestateContext();
  const baseUrl = useAdminBaseUrl();
  const queryClient = useQueryClient();

  return useMutation({
    mutationKey: [`/invocations/${invocationId}/restart-as-new`],
    mutationFn: async ({
      invocationId,
      workflowId,
    }: {
      invocationId: string;
      workflowId: string;
    }) => {
      const data = await queryClient.ensureQueryData(
        adminApi('query', '/query/v2/invocations/{invocationId}', 'get', {
          baseUrl,
          parameters: { path: { invocationId }, query: { journal: true } },
        }),
      );
      const inputEntry = data?.journal?.entries?.find(
        (entry) => entry.type === 'Input',
      ) as Extract<JournalEntryV2, { type?: 'Input'; category?: 'command' }>;
      const body = inputEntry.parameters;
      const headers = inputEntry.headers;

      return fetch(
        `${ingressUrl}/${data?.target_service_name}/${workflowId}/${data?.target_handler_name}/send`,
        {
          method: 'POST',
          body: body ? base64ToUint8Array(body) : undefined,
          headers:
            headers?.reduce(
              (acc, { key, value }) => ({ ...acc, [key]: value }),
              {} as Record<string, string>,
            ) ?? {},
        },
      ).then(async (res) => {
        if (res.ok) {
          return (await res.json()) as {
            invocationId: string;
            status: string;
          };
        } else {
          throw await res.json();
        }
      });
    },
    ...options,
  });
}

export function useResumeInvocation(
  invocationId: string,
  options?: HookMutationOptions<'/invocations/{invocation_id}/resume', 'patch'>,
) {
  const baseUrl = useAdminBaseUrl();
  const queryCLient = useQueryClient();

  return useMutation({
    ...adminApi('mutate', '/invocations/{invocation_id}/resume', 'patch', {
      baseUrl,
      resolvedPath: `/invocations/${invocationId}/resume`,
    }),
    ...options,
    onSuccess(data, variables, context, meta) {
      options?.onSuccess?.(data, variables, context, meta);

      queryCLient.invalidateQueries({
        queryKey: adminApi(
          'query',
          '/query/v2/invocations/{invocationId}',
          'get',
          {
            baseUrl,
            parameters: {
              path: {
                invocationId: String(variables.parameters?.path.invocation_id),
              },
              query: { journal: true },
            },
          },
        ).queryKey,
      });
      queryCLient.invalidateQueries({
        predicate(query) {
          const queryKey = query.queryKey;
          if (
            Array.isArray(queryKey) &&
            queryKey.at(0) === '/query/invocations'
          ) {
            return true;
          }
          return false;
        },
      });
    },
  });
}

export function convertStateToObject<T>(state: { name: string; value: T }[]) {
  return state.reduce(
    (p, c) => ({ ...p, [c.name]: c.value }),
    {} as Record<string, T>,
  );
}

function isValidJSON(value: any) {
  try {
    return Boolean(JSON.stringify(value));
  } catch (error) {
    return false;
  }
}
export function useEditState(
  service: string,
  objectKey: string,
  {
    enabled,
    ...options
  }: UseMutationOptions<
    StateResponse['state'] | undefined,
    RestateError | Error,
    {
      state: Record<string, string | undefined>;
      partial?: boolean;
    }
  > & { enabled?: boolean } = {},
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/services/{name}/keys/{key}/state',
    'get',
    {
      baseUrl,
      parameters: { path: { key: objectKey, name: service } },
    },
  );

  const query = useQuery({ ...queryOptions, enabled });
  const version = query.data?.version;
  const decodedQuery = useDecodeState(
    query.data?.state,
    query.data?.version,
    true,
  );
  const { encoder } = useRestateContext();

  const { mutationFn, mutationKey, meta } = adminApi(
    'mutate',
    '/services/{service}/state',
    'post',
    {
      baseUrl,
      resolvedPath: `/services/${service}/state`,
    },
  );
  const queryClient = useQueryClient();

  const mutate = async (variables: {
    state: Record<string, string | undefined>;
    partial?: boolean;
  }) => {
    if (!version && variables.partial) {
      throw new RestateError(
        'Partial updates to the state are not supported. Please replace the entire state instead.',
      );
    }
    if (
      !variables.state ||
      typeof variables.state !== 'object' ||
      !isValidJSON(variables.state)
    ) {
      throw new RestateError('Please enter a valid value');
    }

    const encodedVariables = convertStateToObject(
      await Promise.all(
        Object.entries(variables.state).map(([k, v]) =>
          Promise.resolve(encoder(v)).then((encodedV) => ({
            name: k,
            value: Array.from(base64ToUint8Array(encodedV)),
          })),
        ),
      ),
    );

    return mutationFn(
      {
        parameters: { path: { service } },
        body: {
          object_key: objectKey,
          ...(variables.partial && {
            version,
          }),
          new_state: {
            ...(variables.partial &&
              query.data && {
                ...convertStateToObject(
                  query.data.state.map(({ name, value }) => ({
                    name,
                    value: Array.from(base64ToUint8Array(value)),
                  })),
                ),
              }),
            ...encodedVariables,
          },
        },
      },
      { client: queryClient, meta },
    ).then(async (res) => {
      const { data: newData } = await query.refetch();

      return newData?.state;
    });
  };

  const mutation = useMutation({
    mutationFn: mutate,
    mutationKey,
    meta,
    onSuccess(data, variables, context, meta) {
      options?.onSuccess?.(data, variables, context, meta);
      queryClient.setQueriesData(
        {
          predicate: (query) => {
            return (
              Array.isArray(query.queryKey) &&
              query.queryKey.at(0) === `/query/services/${service}/state`
            );
          },
        },
        (oldData: ReturnType<typeof useListVirtualObjectState>['data']) => {
          if (!oldData || !data) {
            return oldData;
          } else {
            return {
              ...oldData,
              objects: oldData.objects.map((oldObject) => {
                if (oldObject.key === objectKey) {
                  return {
                    ...oldObject,
                    state: data,
                  };
                } else {
                  return oldObject;
                }
              }),
            };
          }
        },
      );
    },
  });

  return {
    mutation,
    decodedQuery: {
      ...decodedQuery,
      isPending: query.isPending || decodedQuery.isPending,
      error: query.error || decodedQuery.error,
      data: query.data ? decodedQuery.data : undefined,
    },
  };
}

export function useDecode(value?: string, isBase64?: boolean) {
  const { decoder } = useRestateContext();

  return useQuery({
    queryKey: [value, 'decode'],
    queryFn: ({ queryKey }) => {
      const [value] = queryKey;
      return decoder(value);
    },
    staleTime: Infinity,
    refetchOnMount: false,
    placeholderData: value,
    enabled: isBase64,
    initialData: isBase64 ? undefined : value,
  });
}

function safeParse(value: string) {
  try {
    return JSON.parse(value);
  } catch (error) {
    if (value === '') {
      return undefined;
    } else {
      return value;
    }
  }
}
export function useDecodeState(
  state: {
    name: string;
    value: string;
  }[] = [],
  version?: string,
  isBase64?: boolean,
) {
  const { decoder } = useRestateContext();

  return useQueries({
    queries: state.map(({ name, value }) => ({
      queryKey: [value, 'decode'],
      queryFn: async ({ queryKey }: { queryKey: string[] }) => {
        const [value] = queryKey;
        return decoder(value);
      },
      staleTime: Infinity,
      refetchOnMount: false,
      placeholderData: value,
      enabled: isBase64,
      initialData: isBase64 ? undefined : value,
    })),
    combine: (results) => {
      return {
        data: {
          state: convertStateToObject(
            results.filter(Boolean).map((r, i) => ({
              value: safeParse(r.data ?? ''),
              name: state.at(i)!.name,
            })),
          ),
          version,
        },
        error: results.find((r) => r.error)?.error,
        isPending: results.some((r) => r.isFetching),
      };
    },
  });
}

export function useEncode(value?: string, isBase64?: boolean) {
  const { encoder } = useRestateContext();

  return useQuery({
    queryKey: [value, 'decode'],
    queryFn: ({ queryKey }) => {
      const [value] = queryKey;
      return encoder(value);
    },
    staleTime: Infinity,
    refetchOnMount: false,
    placeholderData: value,
    enabled: isBase64,
    initialData: isBase64 ? undefined : value,
  });
}
