import type { paths, components } from './index'; // generated by openapi-typescript
import {
  useMutation,
  UseMutationOptions,
  useQueries,
  useQuery,
  useQueryClient,
  UseQueryResult,
} from '@tanstack/react-query';
import {
  adminApi,
  MutationOptions,
  OperationBody,
  OperationParameters,
  QueryOptions,
  SupportedMethods,
} from './client';
import { useAdminBaseUrl } from '../AdminBaseUrlProvider';
import type {
  DeploymentId,
  Revision,
  ServiceName,
  Deployment,
  FilterItem,
  Service,
  StateResponse,
  Invocation,
  JournalEntry,
} from './type';
import { useCallback, useEffect, useMemo } from 'react';
import { RestateError } from '@restate/util/errors';
import { useAPIStatus } from '../APIStatusProvider';

type HookQueryOptions<
  Path extends keyof paths,
  Method extends SupportedMethods<Path>
> = Omit<QueryOptions<Path, Method>, 'queryFn' | 'queryKey'>;

type HookMutationOptions<
  Path extends keyof paths,
  Method extends SupportedMethods<Path>,
  Parameters extends OperationParameters<Path, Method> = OperationParameters<
    Path,
    Method
  >,
  Body extends OperationBody<Path, Method> = OperationBody<Path, Method>
> = Omit<
  MutationOptions<Path, Method, Parameters, Body>,
  'mutationFn' | 'mutationKey'
>;

const SERVICE_TIMESTAMP = new Map<string, Date>();

function listDeploymentsSelector(
  data:
    | {
        deployments: components['schemas']['DeploymentResponse'][];
      }
    | undefined
) {
  if (!data) {
    return undefined;
  }

  const { deployments: deploymentsFromApi } = data;
  const { services, deployments } = deploymentsFromApi.reduce(
    (results, deployment) => {
      const { services, deployments } = results;
      // TODO: refactor sorting of revisions
      deployment.services.forEach((service) => {
        // eslint-disable-next-line prefer-const
        let { deployments: serviceDeployments, sortedRevisions } =
          services.get(service.name) ?? {};
        const currentRevisionsDeployments: DeploymentId[] =
          serviceDeployments?.[service.revision] ?? [];
        const sortedRevisionsSet = new Set<number>(sortedRevisions);
        sortedRevisionsSet.add(service.revision);

        serviceDeployments = {
          ...serviceDeployments,
          [service.revision]: [...currentRevisionsDeployments, deployment.id],
        };
        services.set(service.name, {
          deployments: serviceDeployments,
          sortedRevisions: Array.from(sortedRevisionsSet).sort((a, b) => b - a),
        });

        deployments.set(deployment.id, deployment);
      });

      services.forEach(
        ({ deployments: deploymentIds, sortedRevisions }, service) => {
          if (!SERVICE_TIMESTAMP.get(service)) {
            const deploymentId =
              deploymentIds[sortedRevisions.at(0) ?? 1]?.at(0);
            const date =
              (deploymentId && deployments.get(deploymentId)?.created_at) ||
              Date.now();

            SERVICE_TIMESTAMP.set(service, new Date(date));
          }
        }
      );
      return { services, deployments };
    },
    {
      services: new Map<
        ServiceName,
        {
          deployments: Record<Revision, DeploymentId[]>;
          sortedRevisions: number[];
        }
      >(),
      deployments: new Map<DeploymentId, Deployment>(),
    }
  );

  const sortedServiceNames = Array.from(services.keys()).sort((a, b) => {
    const bTimestamp = SERVICE_TIMESTAMP.get(b);
    const aTimestamp = SERVICE_TIMESTAMP.get(a);
    if (!aTimestamp || !bTimestamp) {
      return a.localeCompare(b);
    }

    return bTimestamp.getTime() - aTimestamp.getTime() || a.localeCompare(b);
  });
  return { services, deployments, sortedServiceNames };
}

export function useListDeployments(
  options?: HookQueryOptions<'/deployments', 'get'>
) {
  const enabled = useAPIStatus();

  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/deployments', 'get', { baseUrl });

  const results = useQuery({
    ...queryOptions,
    ...options,
    select: listDeploymentsSelector,
    enabled: options?.enabled !== false && enabled,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
    isPending: results.isPending || !enabled,
  };
}

export function useSqlQuery(
  query: string,
  options?: HookQueryOptions<'/query', 'post'>
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/query', 'post', {
    baseUrl,
    body: { query },
  });

  const results = useQuery({
    ...queryOptions,
    ...options,
    enabled: Boolean(query),
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useHealth(options?: HookQueryOptions<'/health', 'get'>) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/health', 'get', { baseUrl });
  return useQuery({
    ...queryOptions,
    ...options,
  });
}

export function useOpenApi(options?: HookQueryOptions<'/openapi', 'get'>) {
  const baseUrl = useAdminBaseUrl();

  return useQuery({
    ...adminApi('query', '/openapi', 'get', { baseUrl }),
    ...options,
  });
}

export function useVersion(options?: HookQueryOptions<'/version', 'get'>) {
  const baseUrl = useAdminBaseUrl();

  return useQuery({
    ...adminApi('query', '/version', 'get', { baseUrl }),
    ...options,
  });
}

export function useRegisterDeployment(
  options?: HookMutationOptions<'/deployments', 'post'>
) {
  const baseUrl = useAdminBaseUrl();

  return useMutation({
    ...adminApi('mutate', '/deployments', 'post', { baseUrl }),
    ...options,
  });
}

function getServiceAdminApi(init: {
  baseUrl: string;
  parameters?: OperationParameters<'/services/{service}', 'get'>;
  resolvedPath?: string;
}) {
  const { queryFn, ...queryOptions } = adminApi(
    'query',
    '/services/{service}',
    'get',
    init
  );

  return {
    ...queryOptions,
    queryFn: (...args: Parameters<typeof queryFn>) =>
      Promise.resolve(queryFn(...args))?.then((data) => {
        if (!data) {
          return data;
        }
        return {
          ...data,
          handlers: data?.handlers.sort((a, b) => a.name.localeCompare(b.name)),
        };
      }),
  };
}

export function useServiceDetails(
  service: string,
  options?: HookQueryOptions<'/services/{service}', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const { queryFn, ...queryOptions } = getServiceAdminApi({
    baseUrl,
    parameters: { path: { service } },
  });

  const results = useQuery({
    staleTime: 0,
    ...queryOptions,
    queryFn: (...args: Parameters<typeof queryFn>) =>
      Promise.resolve(queryFn(...args))?.then((data) => {
        if (!data) {
          return data;
        }
        return {
          ...data,
          handlers: data?.handlers.sort((a, b) => a.name.localeCompare(b.name)),
        };
      }),
    ...options,
  });

  return { ...results, queryKey: queryOptions.queryKey };
}

export function useListServices(
  services: string[] = [],
  options?: HookQueryOptions<'/services/{service}', 'get'>
) {
  const enabled = useAPIStatus();
  const baseUrl = useAdminBaseUrl();

  const results = useQueries({
    queries: services.map((service) => ({
      ...getServiceAdminApi({
        baseUrl,
        parameters: { path: { service } },
      }),
      staleTime: 0,
      ...options,
      enabled: options?.enabled !== false && enabled,
    })),
    combine: (results) => {
      return {
        data: results.reduce((result, service) => {
          if (service.data) {
            result.set(service.data?.name, service.data);
          }
          return result;
        }, new Map<string, Service>()),
        isPending: results.some((result) => result.isPending) || !enabled,
        promise: Promise.all(results.map(({ promise }) => promise)),
      };
    },
  });

  return results;
}

export function useDeploymentDetails(
  deployment: string,
  options?: HookQueryOptions<'/deployments/{deployment}', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/deployments/{deployment}', 'get', {
    baseUrl,
    parameters: { path: { deployment } },
  });

  const results = useQuery({
    staleTime: 0,
    ...queryOptions,
    ...options,
  });

  return { ...results, queryKey: queryOptions.queryKey };
}

export function useModifyService(
  service: string,
  options?: HookMutationOptions<'/services/{service}', 'patch'>
) {
  const baseUrl = useAdminBaseUrl();

  return useMutation({
    ...adminApi('mutate', '/services/{service}', 'patch', {
      baseUrl,
      resolvedPath: `/services/${service}`,
    }),
    ...options,
  });
}

export function useDeleteDeployment(
  deployment: string,
  options?: HookMutationOptions<'/deployments/{deployment}', 'delete'>
) {
  const baseUrl = useAdminBaseUrl();

  return useMutation({
    ...adminApi('mutate', '/deployments/{deployment}', 'delete', {
      baseUrl,
      resolvedPath: `/deployments/${deployment}`,
    }),
    ...options,
  });
}

export function useServiceOpenApi(
  service: string,
  options?: HookQueryOptions<'/services/{service}/openapi', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/services/{service}/openapi', 'get', {
    baseUrl,
    parameters: { path: { service } },
  });

  const results = useQuery({
    staleTime: 0,
    ...queryOptions,
    ...options,
  });

  return { ...results, queryKey: queryOptions.queryKey };
}

export function useListInvocations(
  filters?: FilterItem[],
  options?: HookQueryOptions<'/query/invocations', 'post'>
) {
  const enabled = useAPIStatus();

  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi('query', '/query/invocations', 'post', {
    baseUrl,
    body: {
      filters,
    },
  });

  const results = useQuery({
    ...queryOptions,
    ...options,
    enabled: options?.enabled !== false && enabled,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
    isPending: results.isPending || !enabled,
  };
}

export function useGetInvocation(
  invocationId: string,
  options?: HookQueryOptions<'/query/invocations/{invocationId}', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/invocations/{invocationId}',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId } },
    }
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useGetInvocationJournal(
  invocationId: string,
  options?: HookQueryOptions<'/query/invocations/{invocationId}/journal', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/invocations/{invocationId}/journal',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId } },
    }
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useGetInvocationJournalEntry(
  invocationId: string,
  entryIndex: number,
  options?: HookQueryOptions<
    '/query/invocations/{invocationId}/journal/{entryIndex}',
    'get'
  >
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/invocations/{invocationId}/journal/{entryIndex}',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId, entryIndex } },
    }
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useGetInvocationJournalWithInvocation(
  invocationId: string,
  options?: HookQueryOptions<'/query/invocations/{invocationId}/journal', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const journalQuery = adminApi(
    'query',
    '/query/invocations/{invocationId}/journal',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId } },
    }
  );
  const invocationQuery = adminApi(
    'query',
    '/query/invocations/{invocationId}',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId } },
    }
  );
  const results = useQueries({
    queries: [
      {
        ...journalQuery,
        ...options,
      },
      {
        ...invocationQuery,
        refetchOnMount: options?.refetchOnMount !== false,
        enabled: options?.enabled !== false,
        staleTime: 0,
      },
    ],
    combine: ([journalResults, invocationResults]) => {
      return {
        ...(journalResults.data &&
          invocationResults.data && {
            data: {
              journal: journalResults.data,
              invocation: invocationResults.data,
            },
          }),
        isPending: journalResults.isPending || invocationResults.isPending,
        isSuccess: journalResults.isSuccess && invocationResults.isSuccess,
        dataUpdatedAt: Math.max(
          journalResults.dataUpdatedAt,
          invocationResults.dataUpdatedAt
        ),
        error: journalResults.error || invocationResults.error,
      };
    },
  });

  const queryClient = useQueryClient();

  useEffect(() => {
    queryClient.setQueriesData(
      {
        predicate: (query) => {
          return (
            Array.isArray(query.queryKey) &&
            query.queryKey.at(0) === '/query/invocations'
          );
        },
      },
      (oldData: ReturnType<typeof useListInvocations>['data']) => {
        const newInvocation = results.data?.invocation;
        if (!oldData || !newInvocation) {
          return oldData;
        } else {
          return {
            ...oldData,
            rows: oldData.rows.map((oldInvocation) => {
              if (oldInvocation.id === newInvocation.id) {
                return newInvocation;
              } else {
                return oldInvocation;
              }
            }),
          };
        }
      }
    );
  }, [queryClient, results]);

  return {
    ...results,
    refetch: () => {
      return Promise.all([
        queryClient.refetchQueries({
          queryKey: journalQuery.queryKey,
        }),
        queryClient.refetchQueries({
          queryKey: invocationQuery.queryKey,
        }),
      ]);
    },
  };
}

export function useGetInvocationJournalWithInvocationV2(
  invocationId: string,
  options?: HookQueryOptions<'/query/v2/invocations/{invocationId}', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const query = adminApi(
    'query',
    '/query/v2/invocations/{invocationId}',
    'get',
    {
      baseUrl,
      parameters: { path: { invocationId }, query: { journal: true } },
    }
  );
  const results = useQuery({
    ...query,
    ...options,
  });

  const queryClient = useQueryClient();

  useEffect(() => {
    queryClient.setQueriesData(
      {
        predicate: (query) => {
          return (
            Array.isArray(query.queryKey) &&
            query.queryKey.at(0) === '/query/invocations'
          );
        },
      },
      (oldData: ReturnType<typeof useListInvocations>['data']) => {
        if (results.data && oldData) {
          const { journal, ...newInvocation } = results.data ?? {};
          if (newInvocation) {
            return {
              ...oldData,
              rows: oldData.rows.map((oldInvocation) => {
                if (oldInvocation.id === newInvocation.id) {
                  return newInvocation;
                } else {
                  return oldInvocation;
                }
              }),
            };
          }
        }
        return oldData;
      }
    );
  }, [queryClient, results]);

  return { queryKey: query.queryKey, ...results };
}

export function useGetInvocationsJournalWithInvocationsV2(
  invocationIds: string[],
  options?: HookQueryOptions<'/query/v2/invocations/{invocationId}', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const invocationQueries = useMemo(
    () =>
      invocationIds.map((invocationId) =>
        adminApi('query', '/query/v2/invocations/{invocationId}', 'get', {
          baseUrl,
          parameters: { path: { invocationId }, query: { journal: true } },
        })
      ),
    [baseUrl, invocationIds]
  );

  const combine = useCallback(
    (
      results: UseQueryResult<
        | ReturnType<typeof useGetInvocationJournalWithInvocationV2>['data']
        | undefined,
        Error
      >[]
    ) => {
      return {
        data: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]: results.at(index)?.data,
          };
        }, {} as Record<string, ReturnType<typeof useGetInvocationJournalWithInvocationV2>['data']>),
        isPending: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]: results.at(index)?.isPending,
          };
        }, {} as Record<string, boolean | undefined>),
        isSuccess: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]: results.at(index)?.isSuccess,
          };
        }, {} as Record<string, boolean | undefined>),
        error: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]: results.at(index)?.error,
          };
        }, {} as Record<string, Error | null | undefined>),
        dataUpdatedAt: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]: results.at(index)?.dataUpdatedAt,
          };
        }, {} as Record<string, number | undefined>),
      };
    },
    [invocationIds]
  );

  const results = useQueries({
    queries: [
      ...invocationQueries.map((invocationQuery) => ({
        ...invocationQuery,
        refetchOnMount: options?.refetchOnMount !== false,
        enabled: options?.enabled !== false,
        staleTime: 0,
      })),
    ],
    combine,
  });

  const queryClient = useQueryClient();

  useEffect(() => {
    queryClient.setQueriesData(
      {
        predicate: (query) => {
          return (
            Array.isArray(query.queryKey) &&
            query.queryKey.at(0) === '/query/invocations'
          );
        },
      },
      (oldData: ReturnType<typeof useListInvocations>['data']) => {
        if (!oldData) {
          return oldData;
        } else {
          return {
            ...oldData,
            rows: oldData.rows.map((oldInvocation) => {
              const invResult = results.data?.[oldInvocation.id];
              if (invResult) {
                const { journal, ...newInvocation } = invResult;
                if (newInvocation) {
                  return newInvocation;
                }
              }

              return oldInvocation;
            }),
          };
        }
      }
    );
  }, [queryClient, results]);

  const invalidate = useCallback(() => {
    return Promise.all([
      ...invocationQueries.map((invocationQuery) =>
        queryClient.invalidateQueries({
          queryKey: invocationQuery.queryKey,
        })
      ),
    ]);
  }, [invocationQueries, queryClient]);

  return {
    ...results,
    refetch: () => {
      return Promise.all([
        ...invocationQueries.map((invocationQuery) =>
          queryClient.refetchQueries({
            queryKey: invocationQuery.queryKey,
          })
        ),
      ]);
    },
    invalidate,
  };
}

export function useGetInvocationsJournalWithInvocations(
  invocationIds: string[],
  options?: HookQueryOptions<'/query/invocations/{invocationId}/journal', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const journalQueries = invocationIds.map((invocationId) =>
    adminApi('query', '/query/invocations/{invocationId}/journal', 'get', {
      baseUrl,
      parameters: { path: { invocationId } },
    })
  );
  const invocationQueries = invocationIds.map((invocationId) =>
    adminApi('query', '/query/invocations/{invocationId}', 'get', {
      baseUrl,
      parameters: { path: { invocationId } },
    })
  );

  const combine = useCallback(
    (
      results: UseQueryResult<
        | {
            entries: JournalEntry[];
          }
        | Invocation
        | undefined,
        Error
      >[]
    ) => {
      return {
        data: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]: {
              journal: results.at(index)?.data as {
                entries: JournalEntry[];
              },
              invocation: results.at(index + invocationIds.length)
                ?.data as Invocation,
            },
          };
        }, {} as Record<string, { journal: { entries: JournalEntry[] }; invocation: Invocation }>),
        isPending: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]:
              results.at(index)?.isPending ||
              results.at(index + invocationIds.length)?.isPending,
          };
        }, {} as Record<string, boolean | undefined>),
        isSuccess: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]:
              results.at(index)?.isSuccess &&
              results.at(index + invocationIds.length)?.isSuccess,
          };
        }, {} as Record<string, boolean | undefined>),
        error: invocationIds.reduce((combined, invocationId, index) => {
          return {
            ...combined,
            [invocationId]:
              results.at(index)?.error ||
              results.at(index + invocationIds.length)?.error,
          };
        }, {} as Record<string, Error | null | undefined>),
        dataUpdatedAt: Math.max(
          ...results.map((result) => result.dataUpdatedAt)
        ),
      };
    },
    [invocationIds]
  );

  const results = useQueries({
    queries: [
      ...journalQueries.map((journalQuery) => ({
        ...journalQuery,
        refetchOnMount: options?.refetchOnMount !== false,
        enabled: options?.enabled !== false,
        staleTime: 0,
      })),
      ...invocationQueries.map((invocationQuery) => ({
        ...invocationQuery,
        refetchOnMount: options?.refetchOnMount !== false,
        enabled: options?.enabled !== false,
        staleTime: 0,
      })),
    ],
    combine,
  });

  const queryClient = useQueryClient();

  useEffect(() => {
    queryClient.setQueriesData(
      {
        predicate: (query) => {
          return (
            Array.isArray(query.queryKey) &&
            query.queryKey.at(0) === '/query/invocations'
          );
        },
      },
      (oldData: ReturnType<typeof useListInvocations>['data']) => {
        if (!oldData) {
          return oldData;
        } else {
          return {
            ...oldData,
            rows: oldData.rows.map((oldInvocation) => {
              const newInvocation =
                results.data?.[oldInvocation.id]?.invocation;
              if (newInvocation) {
                return newInvocation;
              } else {
                return oldInvocation;
              }
            }),
          };
        }
      }
    );
  }, [queryClient, results]);

  return {
    ...results,
    refetch: () => {
      return Promise.all([
        ...journalQueries.map((journalQuery) =>
          queryClient.refetchQueries({
            queryKey: journalQuery.queryKey,
          })
        ),
        ...invocationQueries.map((invocationQuery) =>
          queryClient.refetchQueries({
            queryKey: invocationQuery.queryKey,
          })
        ),
      ]);
    },
    invalidate: () => {
      return Promise.all([
        ...journalQueries.map((journalQuery) =>
          queryClient.invalidateQueries({
            queryKey: journalQuery.queryKey,
          })
        ),
        ...invocationQueries.map((invocationQuery) =>
          queryClient.invalidateQueries({
            queryKey: invocationQuery.queryKey,
          })
        ),
      ]);
    },
  };
}

export function useGetVirtualObjectQueue(
  serviceName: string,
  key: string,
  invocationId?: string,
  options?: HookQueryOptions<
    '/query/virtualObjects/{name}/keys/{key}/queue',
    'get'
  >
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/virtualObjects/{name}/keys/{key}/queue',
    'get',
    {
      baseUrl,
      parameters: { path: { key, name: serviceName }, query: { invocationId } },
    }
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useGetVirtualObjectState(
  serviceName: string,
  key: string,
  options?: HookQueryOptions<'/query/services/{name}/keys/{key}/state', 'get'>
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/services/{name}/keys/{key}/state',
    'get',
    {
      baseUrl,
      parameters: { path: { key, name: serviceName } },
    }
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useQueryVirtualObjectState(
  serviceName: string,
  filters?: FilterItem[],
  options?: HookQueryOptions<'/query/services/{name}/state/query', 'post'>
) {
  const enabled = useAPIStatus();
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/services/{name}/state/query',
    'post',
    {
      baseUrl,
      parameters: { path: { name: serviceName } },
      body: {
        filters,
      },
      resolvedPath: `/query/services/${serviceName}/state/query`,
    }
  );
  const results = useQuery({
    ...queryOptions,
    ...options,
    enabled: options?.enabled !== false && enabled,
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
    isPending: results.isPending || !enabled,
  };
}

export function useListVirtualObjectState(
  serviceName: string,
  keys: string[],
  options?: HookQueryOptions<'/query/services/{name}/state', 'post'>
) {
  const baseUrl = useAdminBaseUrl();
  const queryOptions = adminApi(
    'query',
    '/query/services/{name}/state',
    'post',
    {
      baseUrl,
      parameters: { path: { name: serviceName } },
      body: {
        keys,
      },
      resolvedPath: `/query/services/${serviceName}/state`,
    }
  );

  const results = useQuery({
    ...queryOptions,
    ...options,
    ...(keys.length === 0 && { enabled: false }),
  });

  return {
    ...results,
    queryKey: queryOptions.queryKey,
  };
}

export function useDeleteInvocation(
  invocation_id: string,
  options?: HookMutationOptions<'/invocations/{invocation_id}', 'delete'>
) {
  const baseUrl = useAdminBaseUrl();

  return useMutation({
    ...adminApi('mutate', '/invocations/{invocation_id}', 'delete', {
      baseUrl,
      resolvedPath: `/invocations/${invocation_id}`,
    }),
    ...options,
  });
}

function convertStateToUnit8Array(state: Record<string, string | undefined>) {
  return Object.entries(state).reduce(
    (results, [k, v]) => ({
      ...results,
      [k]: Array.from(new TextEncoder().encode(v)),
    }),
    {} as Record<string, number[]>
  );
}

export function convertStateToObject(state: { name: string; value: string }[]) {
  return state.reduce(
    (p, c) => ({ ...p, [c.name]: c.value }),
    {} as Record<string, string>
  );
}

function isValidJSON(value: any) {
  try {
    return Boolean(JSON.stringify(value));
  } catch (error) {
    return false;
  }
}
export function useEditState(
  service: string,
  objectKey: string,
  {
    enabled,
    ...options
  }: UseMutationOptions<
    StateResponse['state'] | undefined,
    RestateError | Error,
    {
      state: Record<string, string | undefined>;
      partial?: boolean;
    }
  > & { enabled?: boolean } = {}
) {
  const baseUrl = useAdminBaseUrl();

  const queryOptions = adminApi(
    'query',
    '/query/services/{name}/keys/{key}/state',
    'get',
    {
      baseUrl,
      parameters: { path: { key: objectKey, name: service } },
    }
  );

  const query = useQuery({ ...queryOptions, enabled });

  const { mutationFn, mutationKey, meta } = adminApi(
    'mutate',
    '/services/{service}/state',
    'post',
    {
      baseUrl,
      resolvedPath: `/services/${service}/state`,
    }
  );

  const mutate = (variables: {
    state: Record<string, string | undefined>;
    partial?: boolean;
  }) => {
    if (!query.data?.version) {
      throw new RestateError(
        'Modifying the state is only allowed in an HTTPS context.'
      );
    }
    if (
      !variables.state ||
      typeof variables.state !== 'object' ||
      !isValidJSON(variables.state)
    ) {
      throw new RestateError('Please enter a valid value');
    }

    return mutationFn({
      parameters: { path: { service } },
      body: {
        object_key: objectKey,
        ...(variables.partial && {
          version: query.data?.version,
        }),
        new_state: {
          ...(variables.partial && {
            ...convertStateToUnit8Array(convertStateToObject(query.data.state)),
          }),
          ...convertStateToUnit8Array(variables.state),
        },
      },
    }).then(async (res) => {
      const { data: newData } = await query.refetch();

      return newData?.state;
    });
  };

  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: mutate,
    mutationKey,
    meta,
    onSuccess(data, variables, context) {
      options?.onSuccess?.(data, variables, context);
      queryClient.setQueriesData(
        {
          predicate: (query) => {
            return (
              Array.isArray(query.queryKey) &&
              query.queryKey.at(0) === `/query/services/${service}/state`
            );
          },
        },
        (oldData: ReturnType<typeof useListVirtualObjectState>['data']) => {
          if (!oldData || !data) {
            return oldData;
          } else {
            return {
              ...oldData,
              objects: oldData.objects.map((oldObject) => {
                if (oldObject.key === objectKey) {
                  return {
                    ...oldObject,
                    state: data,
                  };
                } else {
                  return oldObject;
                }
              }),
            };
          }
        }
      );
    },
  });

  return { mutation, query };
}
