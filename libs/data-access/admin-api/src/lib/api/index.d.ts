/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/cluster-health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Cluster health
     * @description Get the cluster health.
     */
    get: operations['cluster_health'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/deployments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List deployments
     * @description List all registered deployments.
     */
    get: operations['list_deployments'];
    put?: never;
    /**
     * Create deployment
     * @description Create and register a new deployment. Restate will invoke the endpoint to gather additional information required for registration, such as the services exposed by the deployment. If the deployment is already registered, this method will return 200 and no changes will be made. If the deployment updates some already existing services, schema breaking changes checks will run. If you want to bypass them, use `breaking: true`. To overwrite an already existing deployment, use `force: true`
     */
    post: operations['create_deployment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/deployments/{deployment}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get deployment
     * @description Get deployment metadata
     */
    get: operations['get_deployment'];
    put?: never;
    post?: never;
    /**
     * Delete deployment
     * @description Delete deployment. Currently it's supported to remove a deployment only using the force flag
     */
    delete: operations['delete_deployment'];
    options?: never;
    head?: never;
    /**
     * Update deployment
     * @description Update an already existing deployment. This lets you update the address and options when invoking the deployment, such as the additional headers for HTTP or the assume role for Lambda. The registered services and handlers won't be overwritten, unless `overwrite: true`.
     */
    patch: operations['update_deployment'];
    trace?: never;
  };
  '/health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Health check
     * @description Check REST API Health.
     */
    get: operations['health'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/invocations/{invocation_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete an invocation
     * @deprecated
     * @description Use kill_invocation/cancel_invocation/purge_invocation instead.
     */
    delete: operations['delete_invocation'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/invocations/{invocation_id}/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Cancel an invocation
     * @description Cancel the given invocation. Canceling an invocation allows it to free any resources it is holding and roll back any changes it has made so far, running compensation code. For more details, checkout https://docs.restate.dev/guides/sagas
     */
    patch: operations['cancel_invocation'];
    trace?: never;
  };
  '/invocations/{invocation_id}/kill': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Kill an invocation
     * @description Kill the given invocation. This does not guarantee consistency for virtual object instance state, in-flight invocations to other services, etc.
     */
    patch: operations['kill_invocation'];
    trace?: never;
  };
  '/invocations/{invocation_id}/pause': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Pause an invocation
     * @description Pause the given invocation. This applies only to running invocations, and will cause them to eventually pause.
     */
    patch: operations['pause_invocation'];
    trace?: never;
  };
  '/invocations/{invocation_id}/purge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Purge an invocation
     * @description Purge the given invocation. This cleanups all the state for the given invocation. This command applies only to completed invocations.
     */
    patch: operations['purge_invocation'];
    trace?: never;
  };
  '/invocations/{invocation_id}/purge-journal': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Purge an invocation journal
     * @description Purge the given invocation journal. This cleanups only the journal for the given invocation, retaining the metadata. This command applies only to completed invocations.
     */
    patch: operations['purge_journal'];
    trace?: never;
  };
  '/invocations/{invocation_id}/restart-as-new': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Restart as new invocation
     * @description Restart the given invocation as new. This will restart the invocation as a new invocation with a different invocation id. By using the 'from' query parameter, some of the partial progress can be copied over to the new invocation.
     */
    patch: operations['restart_as_new_invocation'];
    trace?: never;
  };
  '/invocations/{invocation_id}/resume': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Resume an invocation
     * @description Resume the given invocation. In case the invocation is backing-off, this will immediately trigger the retry timer. If the invocation is suspended or paused, this will resume it.
     */
    patch: operations['resume_invocation'];
    trace?: never;
  };
  '/openapi': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** OpenAPI specification */
    get: operations['openapi_spec'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List services
     * @description List all registered services.
     */
    get: operations['list_services'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{service}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get service
     * @description Get a registered service.
     */
    get: operations['get_service'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Modify a service
     * @description Modify a registered service configuration. NOTE: Service re-discovery will update the settings based on the service endpoint configuration.
     */
    patch: operations['modify_service'];
    trace?: never;
  };
  '/services/{service}/handlers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List service handlers
     * @description List all the handlers of the given service.
     */
    get: operations['list_service_handlers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{service}/handlers/{handler}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get service handler
     * @description Get the handler of a service
     */
    get: operations['get_service_handler'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{service}/openapi': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get service OpenAPI
     * @description Get the service OpenAPI 3.1 contract.
     */
    get: operations['get_service_openapi'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{service}/state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Modify a service state
     * @description Modify service state
     */
    post: operations['modify_service_state'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscriptions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List subscriptions
     * @description List all subscriptions.
     */
    get: operations['list_subscriptions'];
    put?: never;
    /**
     * Create subscription
     * @description Create subscription.
     */
    post: operations['create_subscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscriptions/{subscription}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get subscription
     * @description Get subscription
     */
    get: operations['get_subscription'];
    put?: never;
    post?: never;
    /**
     * Delete subscription
     * @description Delete subscription.
     */
    delete: operations['delete_subscription'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Admin version information
     * @description Obtain admin version information.
     */
    get: operations['version'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query journal
     * @description Query journal
     */
    post: operations['query'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List invocations
     * @description List invocations
     */
    post: operations['list_invocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Count invocations
     * @description Count invocations
     */
    post: operations['count_invocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch cancel invocations
     * @description Batch cancel invocations
     */
    post: operations['batch_cancel_invocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/purge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch purge invocations
     * @description Batch purge invocations
     */
    post: operations['batch_purge_invocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/kill': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch kill invocations
     * @description Batch kill invocations
     */
    post: operations['batch_kill_invocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/pause': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch pause invocations
     * @description Batch pause invocations
     */
    post: operations['batch_pause_invocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/resume': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch resume invocations
     * @description Batch resume invocations
     */
    post: operations['batch_resume_invocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/{invocationId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get invocation
     * @description Get invocation
     */
    get: operations['get_invocation'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/{invocationId}/journal': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get invocation journal
     * @description Get invocation journal
     */
    get: operations['get_invocation_journal'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/invocations/{invocationId}/journal/{entryIndex}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get journal entry
     * @description Get journal entry
     */
    get: operations['get_journal_entry'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/v2/invocations/{invocationId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get invocation and journal
     * @description Get invocation journal v2
     */
    get: operations['get_invocation_journal_v2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/virtualObjects/{name}/keys/{key}/queue': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Virtual Object inbox inbox for a key
     * @description Get Virtual Object inbox inbox for a key
     */
    get: operations['get_inbox'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/services/{name}/state/keys': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get state keys
     * @description Get state keys
     */
    get: operations['get_state_keys'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/services/{name}/state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List virtual object state
     * @description List virtual object state
     */
    post: operations['list_virtual_object_state'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/services/{name}/keys/{key}/state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get state keys
     * @description Get state keys
     */
    get: operations['get_state'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/query/services/{name}/state/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query virtual object state
     * @description Query virtual object state
     */
    post: operations['query_virtual_object_state'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    ClusterHealthResponse: {
      /** @description Cluster name */
      cluster_name: string;
      /** @description Embedded metadata cluster health if it was enabled */
      metadata_cluster_health?:
        | components['schemas']['EmbeddedMetadataClusterHealth']
        | null;
    };
    EmbeddedMetadataClusterHealth: {
      /** @description Current members of the embedded metadata cluster */
      members: number[];
    };
    /**
     * Error description response
     * @description Error details of the response
     */
    ErrorDescriptionResponse: {
      message: string;
      /**
       * Restate code
       * @description Restate error code describing this error
       */
      restate_code?: string | null;
    };
    ListDeploymentsResponse: {
      deployments: components['schemas']['DeploymentResponse'][];
    };
    DeploymentResponse:
      | {
          /** Deployment ID */
          id: components['schemas']['String'];
          /**
           * Deployment URI
           * @description URI used to invoke this service deployment.
           */
          uri: string;
          /**
           * Protocol Type
           * @description Protocol type used to invoke this service deployment.
           */
          protocol_type: components['schemas']['ProtocolType'];
          /**
           * HTTP Version
           * @description HTTP Version used to invoke this service deployment.
           */
          http_version: string;
          /**
           * Additional headers
           * @description Additional headers used to invoke this service deployment.
           */
          additional_headers?: {
            [key: string]: string;
          };
          /**
           * Metadata
           * @description Deployment metadata.
           */
          metadata?: {
            [key: string]: string;
          };
          created_at: string;
          /**
           * Minimum Service Protocol version
           * Format: int32
           * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
           */
          min_protocol_version: number;
          /**
           * Maximum Service Protocol version
           * Format: int32
           * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
           */
          max_protocol_version: number;
          /**
           * SDK version
           * @description SDK library and version declared during registration.
           */
          sdk_version?: string | null;
          /**
           * Services
           * @description List of services exposed by this deployment.
           */
          services: components['schemas']['ServiceNameRevPair'][];
          /**
           * Info
           * @description List of configuration/deprecation information related to this deployment.
           */
          info?: components['schemas']['Info'][];
        }
      | {
          /** Deployment ID */
          id: components['schemas']['String'];
          /**
           * Lambda ARN
           * @description Lambda ARN used to invoke this service deployment.
           */
          arn: components['schemas']['LambdaARN'];
          /**
           * Assume role ARN
           * @description Assume role ARN used to invoke this deployment. Check https://docs.restate.dev/category/aws-lambda for more details.
           */
          assume_role_arn?: string | null;
          /**
           * Compression
           * @description Compression algorithm used for invoking Lambda.
           */
          compression?:
            | components['schemas']['EndpointLambdaCompression']
            | null;
          /**
           * Additional headers
           * @description Additional headers used to invoke this service deployment.
           */
          additional_headers?: {
            [key: string]: string;
          };
          /**
           * Metadata
           * @description Deployment metadata.
           */
          metadata?: {
            [key: string]: string;
          };
          created_at: string;
          /**
           * Minimum Service Protocol version
           * Format: int32
           * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
           */
          min_protocol_version: number;
          /**
           * Maximum Service Protocol version
           * Format: int32
           * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
           */
          max_protocol_version: number;
          /**
           * SDK version
           * @description SDK library and version declared during registration.
           */
          sdk_version?: string | null;
          /**
           * Services
           * @description List of services exposed by this deployment.
           */
          services: components['schemas']['ServiceNameRevPair'][];
          /**
           * Info
           * @description List of configuration/deprecation information related to this deployment.
           */
          info?: components['schemas']['Info'][];
        };
    String: string;
    /** @enum {string} */
    ProtocolType: 'RequestResponse' | 'BidiStream';
    ServiceNameRevPair: {
      name: string;
      /** Format: uint32 */
      revision: number;
    };
    Info: {
      code?: string | null;
      message: string;
    };
    /** Format: arn */
    LambdaARN: string;
    /**
     * @description Lambda compression
     * @enum {string}
     */
    EndpointLambdaCompression: 'Zstd';
    RegisterDeploymentRequest:
      | {
          /**
           * Uri
           * @description Uri to use to discover/invoke the http deployment.
           */
          uri: string;
          /**
           * Additional headers
           * @description Additional headers added to every discover/invoke request to the deployment.
           *
           *     You typically want to include here API keys and other tokens required to send requests to deployments.
           */
          additional_headers?: {
            [key: string]: string;
          } | null;
          /**
           * Metadata
           * @description Deployment metadata.
           */
          metadata?: {
            [key: string]: string;
          };
          /**
           * Use http1.1
           * @description If `true`, discovery will be attempted using a client that defaults to HTTP1.1 instead of a prior-knowledge HTTP2 client. HTTP2 may still be used for TLS servers that advertise HTTP2 support via ALPN. HTTP1.1 deployments will only work in request-response mode.
           * @default false
           */
          use_http_11: boolean;
          /**
           * Breaking
           * @description If `true`, it allows registering new service revisions with schemas incompatible with previous service revisions, such as changing service type, removing a handler, etc.
           *
           *     See the [versioning documentation](https://docs.restate.dev/operate/versioning) for more information.
           * @default false
           */
          breaking: boolean;
          /**
           * Force
           * @description If `true`, it overrides, if existing, any deployment using the same `uri`. Beware that this can lead inflight invocations to an unrecoverable error state.
           *
           *     When set to `true`, it implies `breaking = true`.
           *
           *     See the [versioning documentation](https://docs.restate.dev/operate/versioning) for more information.
           * @default true
           */
          force: boolean;
          /**
           * Dry-run mode
           * @description If `true`, discovery will run but the deployment will not be registered. This is useful to see the impact of a new deployment before registering it. `force` and `breaking` will be respected.
           * @default false
           */
          dry_run: boolean;
        }
      | {
          /**
           * ARN
           * @description ARN to use to discover/invoke the lambda deployment.
           */
          arn: string;
          /**
           * Assume role ARN
           * @description Optional ARN of a role to assume when invoking the addressed Lambda, to support role chaining
           */
          assume_role_arn?: string | null;
          /**
           * Additional headers
           * @description Additional headers added to every discover/invoke request to the deployment.
           */
          additional_headers?: {
            [key: string]: string;
          } | null;
          /**
           * Metadata
           * @description Deployment metadata.
           */
          metadata?: {
            [key: string]: string;
          };
          /**
           * Breaking
           * @description If `true`, it allows registering new service revisions with schemas incompatible with previous service revisions, such as changing service type, removing a handler, etc.
           *
           *     See the [versioning documentation](https://docs.restate.dev/operate/versioning) for more information.
           * @default false
           */
          breaking: boolean;
          /**
           * Force
           * @description If `true`, it overrides, if existing, any deployment using the same `uri`. Beware that this can lead inflight invocations to an unrecoverable error state.
           *
           *     This implies `breaking = true`.
           *
           *     See the [versioning documentation](https://docs.restate.dev/operate/versioning) for more information.
           * @default true
           */
          force: boolean;
          /**
           * Dry-run mode
           * @description If `true`, discovery will run but the deployment will not be registered. This is useful to see the impact of a new deployment before registering it. `force` and `breaking` will be respected.
           * @default false
           */
          dry_run: boolean;
        };
    RegisterDeploymentResponse: {
      id: components['schemas']['String'];
      services: components['schemas']['ServiceMetadata'][];
      /**
       * Minimum Service Protocol version
       * Format: int32
       * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
       * @default 0
       */
      min_protocol_version: number;
      /**
       * Maximum Service Protocol version
       * Format: int32
       * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
       * @default 0
       */
      max_protocol_version: number;
      /**
       * SDK version
       * @description SDK library and version declared during registration.
       */
      sdk_version?: string | null;
      /**
       * Info
       * @description List of configuration/deprecation information related to this deployment.
       */
      info?: components['schemas']['Info'][];
    };
    ServiceMetadata: {
      /**
       * Name
       * @description Fully qualified name of the service
       */
      name: string;
      /**
       * Type
       * @description Service type
       */
      ty: components['schemas']['ServiceType'];
      /**
       * Handlers
       * @description Handlers for this service.
       */
      handlers: components['schemas']['HandlerMetadata'][];
      /**
       * Documentation
       * @description Documentation of the service, as propagated by the SDKs.
       */
      documentation?: string | null;
      /**
       * Metadata
       * @description Additional service metadata, as propagated by the SDKs.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Deployment Id
       * @description Deployment exposing the latest revision of the service.
       */
      deployment_id: components['schemas']['String'];
      /**
       * Revision
       * Format: uint32
       * @description Latest revision of the service.
       */
      revision: number;
      /**
       * Public
       * @description If true, the service can be invoked through the ingress. If false, the service can be invoked only from another Restate service.
       * @default true
       */
      public: boolean;
      /**
       * Idempotency retention
       * @description The retention duration of idempotent requests for this service.
       *
       *     If not configured, this returns the default idempotency retention.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       * @default 1d
       */
      idempotency_retention: string;
      /**
       * Workflow completion retention
       * @description The retention duration of workflows. Only available on workflow services.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       */
      workflow_completion_retention?: string | null;
      /**
       * Journal retention
       * @description The journal retention. When set, this applies to all requests to all handlers of this service.
       *
       *     In case the invocation has an idempotency key, the `idempotency_retention` caps the maximum `journal_retention` time. In case the invocation targets a workflow handler, the `workflow_completion_retention` caps the maximum `journal_retention` time.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       */
      journal_retention?: string | null;
      /**
       * Inactivity timeout
       * @description This timer guards against stalled service/handler invocations. Once it expires, Restate triggers a graceful termination by asking the service invocation to suspend (which preserves intermediate progress).
       *
       *     The 'abort timeout' is used to abort the invocation, in case it doesn't react to the request to suspend.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       *
       *     If unset, this returns the default inactivity timeout configured in invoker options.
       * @default 1m
       */
      inactivity_timeout: string;
      /**
       * Abort timeout
       * @description This timer guards against stalled service/handler invocations that are supposed to terminate. The abort timeout is started after the 'inactivity timeout' has expired and the service/handler invocation has been asked to gracefully terminate. Once the timer expires, it will abort the service/handler invocation.
       *
       *     This timer potentially **interrupts** user code. If the user code needs longer to gracefully terminate, then this value needs to be set accordingly.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       *
       *     If unset, this returns the default abort timeout configured in invoker options.
       * @default 1m
       */
      abort_timeout: string;
      /**
       * Enable lazy state
       * @description If true, lazy state will be enabled for all invocations to this service. This is relevant only for Workflows and Virtual Objects.
       * @default false
       */
      enable_lazy_state: boolean;
      /**
       * Retry policy
       * @description Retry policy applied to invocations of this service.
       *
       *     If unset, it returns the default values configured in the Restate configuration.
       * @default {
       *       "exponentiation_factor": 2,
       *       "initial_interval": "100ms",
       *       "max_attempts": null,
       *       "max_interval": null,
       *       "on_max_attempts": "Pause"
       *     }
       */
      retry_policy: components['schemas']['ServiceRetryPolicyMetadata'];
      /**
       * Info
       * @description List of configuration/deprecation information related to this service.
       */
      info?: components['schemas']['Info'][];
    };
    /** @enum {string} */
    ServiceType: 'Service' | 'VirtualObject' | 'Workflow';
    HandlerMetadata: {
      /**
       * Name
       * @description The handler name.
       */
      name: string;
      /**
       * Type
       * @description The handler type.
       */
      ty?: components['schemas']['HandlerMetadataType'] | null;
      /**
       * Documentation
       * @description Documentation of the handler, as propagated by the SDKs.
       */
      documentation?: string | null;
      /**
       * Metadata
       * @description Additional handler metadata, as propagated by the SDKs.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Idempotency retention
       * @description The retention duration of idempotent requests for this handler. If set, it overrides the value set in the service.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       */
      idempotency_retention?: string | null;
      /**
       * Journal retention
       * @description The journal retention. When set, this applies to all requests to this handler.
       *
       *     In case the invocation has an idempotency key, the `idempotency_retention` caps the maximum `journal_retention` time. In case this handler is a workflow handler, the `workflow_completion_retention` caps the maximum `journal_retention` time.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       *
       *     If set, it overrides the value set in the service.
       */
      journal_retention?: string | null;
      /**
       * Inactivity timeout
       * @description This timer guards against stalled service/handler invocations. Once it expires, Restate triggers a graceful termination by asking the service invocation to suspend (which preserves intermediate progress).
       *
       *     The 'abort timeout' is used to abort the invocation, in case it doesn't react to the request to suspend.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       *
       *     If set, it overrides the value set in the service.
       */
      inactivity_timeout?: string | null;
      /**
       * Abort timeout
       * @description This timer guards against stalled service/handler invocations that are supposed to terminate. The abort timeout is started after the 'inactivity timeout' has expired and the service/handler invocation has been asked to gracefully terminate. Once the timer expires, it will abort the service/handler invocation.
       *
       *     This timer potentially **interrupts** user code. If the user code needs longer to gracefully terminate, then this value needs to be set accordingly.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       *
       *     If set, it overrides the value set in the service.
       */
      abort_timeout?: string | null;
      /**
       * Enable lazy state
       * @description If true, lazy state will be enabled for all invocations to this service. This is relevant only for Workflows and Virtual Objects.
       *
       *     If set, it overrides the value set in the service.
       */
      enable_lazy_state?: boolean | null;
      /**
       * Public
       * @description If true, this handler can be invoked through the ingress. If false, this handler can be invoked only from another Restate service.
       * @default true
       */
      public: boolean;
      /**
       * Human readable input description
       * @description If empty, no schema was provided by the user at discovery time.
       */
      input_description: string;
      /**
       * Human readable output description
       * @description If empty, no schema was provided by the user at discovery time.
       */
      output_description: string;
      /**
       * Input JSON Schema
       * @description JSON Schema of the handler input
       */
      input_json_schema?: unknown;
      /**
       * Output JSON Schema
       * @description JSON Schema of the handler output
       */
      output_json_schema?: unknown;
      /**
       * Retry policy
       * @description Retry policy overrides applied for this handler.
       * @default {}
       */
      retry_policy: components['schemas']['HandlerRetryPolicyMetadata'];
      /**
       * Info
       * @description List of configuration/deprecation information related to this handler.
       */
      info?: components['schemas']['Info'][];
    };
    /** @enum {string} */
    HandlerMetadataType: 'Exclusive' | 'Shared' | 'Workflow';
    /** Handler retry policy overrides */
    HandlerRetryPolicyMetadata: {
      /**
       * Initial Interval
       * @description Initial interval for the first retry attempt.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       */
      initial_interval?: string | null;
      /**
       * Factor
       * Format: float
       * @description The factor to use to compute the next retry attempt.
       */
      exponentiation_factor?: number | null;
      /**
       * Max attempts
       * Format: uint
       * @description Number of maximum attempts (including the initial) before giving up. Infinite retries if unset. No retries if set to 1.
       */
      max_attempts?: number | null;
      /**
       * Max interval
       * @description Maximum interval between retries.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       */
      max_interval?: string | null;
      /**
       * On max attempts
       * @description Behavior when max attempts are reached.
       */
      on_max_attempts?: components['schemas']['OnMaxAttempts'] | null;
    };
    OnMaxAttempts: 'Pause' | 'Kill';
    /** Service retry policy */
    ServiceRetryPolicyMetadata: {
      /**
       * Initial Interval
       * @description Initial interval for the first retry attempt.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       * @default 100ms
       */
      initial_interval: string;
      /**
       * Factor
       * Format: float
       * @description The factor to use to compute the next retry attempt. Default: `2.0`.
       * @default 2
       */
      exponentiation_factor: number;
      /**
       * Max attempts
       * Format: uint
       * @description Number of maximum attempts (including the initial) before giving up. Infinite retries if unset. No retries if set to 1.
       * @default null
       */
      max_attempts: number | null;
      /**
       * Max interval
       * @description Maximum interval between retries.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       * @default null
       */
      max_interval: string | null;
      /**
       * On max attempts
       * @description Behavior when max attempts are reached.
       * @default Pause
       */
      on_max_attempts: components['schemas']['OnMaxAttempts'];
    };
    DetailedDeploymentResponse:
      | {
          /** Deployment ID */
          id: components['schemas']['String'];
          /**
           * Deployment URI
           * @description URI used to invoke this service deployment.
           */
          uri: string;
          /**
           * Protocol Type
           * @description Protocol type used to invoke this service deployment.
           */
          protocol_type: components['schemas']['ProtocolType'];
          /**
           * HTTP Version
           * @description HTTP Version used to invoke this service deployment.
           */
          http_version: string;
          /**
           * Additional headers
           * @description Additional headers used to invoke this service deployment.
           */
          additional_headers?: {
            [key: string]: string;
          };
          /**
           * Metadata
           * @description Deployment metadata.
           */
          metadata?: {
            [key: string]: string;
          };
          created_at: string;
          /**
           * Minimum Service Protocol version
           * Format: int32
           * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
           */
          min_protocol_version: number;
          /**
           * Maximum Service Protocol version
           * Format: int32
           * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
           */
          max_protocol_version: number;
          /**
           * SDK version
           * @description SDK library and version declared during registration.
           */
          sdk_version?: string | null;
          /**
           * Services
           * @description List of services exposed by this deployment.
           */
          services: components['schemas']['ServiceMetadata'][];
          /**
           * Info
           * @description List of configuration/deprecation information related to this deployment.
           */
          info?: components['schemas']['Info'][];
        }
      | {
          /** Deployment ID */
          id: components['schemas']['String'];
          /**
           * Lambda ARN
           * @description Lambda ARN used to invoke this service deployment.
           */
          arn: components['schemas']['LambdaARN'];
          /**
           * Assume role ARN
           * @description Assume role ARN used to invoke this deployment. Check https://docs.restate.dev/category/aws-lambda for more details.
           */
          assume_role_arn?: string | null;
          /**
           * Compression
           * @description Compression algorithm used for invoking Lambda.
           */
          compression?:
            | components['schemas']['EndpointLambdaCompression']
            | null;
          /**
           * Additional headers
           * @description Additional headers used to invoke this service deployment.
           */
          additional_headers?: {
            [key: string]: string;
          };
          /**
           * Metadata
           * @description Deployment metadata.
           */
          metadata?: {
            [key: string]: string;
          };
          created_at: string;
          /**
           * Minimum Service Protocol version
           * Format: int32
           * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
           */
          min_protocol_version: number;
          /**
           * Maximum Service Protocol version
           * Format: int32
           * @description During registration, the SDKs declare a range from minimum (included) to maximum (included) Service Protocol supported version.
           */
          max_protocol_version: number;
          /**
           * SDK version
           * @description SDK library and version declared during registration.
           */
          sdk_version?: string | null;
          /**
           * Services
           * @description List of services exposed by this deployment.
           */
          services: components['schemas']['ServiceMetadata'][];
          /**
           * Info
           * @description List of configuration/deprecation information related to this deployment.
           */
          info?: components['schemas']['Info'][];
        };
    UpdateDeploymentRequest:
      | {
          /**
           * Uri
           * @description Uri to use to discover/invoke the http deployment.
           */
          uri?: string | null;
          /**
           * Additional headers
           * @description Additional headers added to the discover/invoke requests to the deployment. When provided, this will overwrite all the headers previously configured for this deployment.
           */
          additional_headers?: {
            [key: string]: string;
          } | null;
          /**
           * Use http1.1
           * @description If `true`, discovery will be attempted using a client that defaults to HTTP1.1 instead of a prior-knowledge HTTP2 client. HTTP2 may still be used for TLS servers that advertise HTTP2 support via ALPN. HTTP1.1 deployments will only work in request-response mode.
           */
          use_http_11?: boolean | null;
          /**
           * Overwrite
           * @description If `true`, the update will overwrite the schema information, including the exposed service and handlers and service configuration, allowing **breaking changes** too. Use with caution.
           * @default false
           */
          overwrite: boolean;
          /**
           * Dry-run mode
           * @description If `true`, discovery will run but the deployment will not be registered. This is useful to see the impact of a new deployment before registering it.
           * @default false
           */
          dry_run: boolean;
        }
      | {
          /**
           * ARN
           * @description ARN to use to discover/invoke the lambda deployment.
           */
          arn?: string | null;
          /**
           * Assume role ARN
           * @description Optional ARN of a role to assume when invoking the addressed Lambda, to support role chaining.
           */
          assume_role_arn?: string | null;
          /**
           * Additional headers
           * @description Additional headers added to the discover/invoke requests to the deployment. When provided, this will overwrite all the headers previously configured for this deployment.
           */
          additional_headers?: {
            [key: string]: string;
          } | null;
          /**
           * Overwrite
           * @description If `true`, the update will overwrite the schema information, including the exposed service and handlers and service configuration, allowing **breaking changes** too. Use with caution.
           * @default false
           */
          overwrite: boolean;
          /**
           * Dry-run mode
           * @description If `true`, discovery will run but the deployment will not be registered. This is useful to see the impact of a new deployment before registering it.
           * @default false
           */
          dry_run: boolean;
        };
    /** @enum {string} */
    DeletionMode: 'Cancel' | 'Kill' | 'Purge';
    RestartAsNewInvocationResponse: {
      /** @description The invocation id of the new invocation. */
      new_invocation_id: components['schemas']['String'];
    };
    ListServicesResponse: {
      services: components['schemas']['ServiceMetadata'][];
    };
    ModifyServiceRequest: {
      /**
       * Public
       * @description If true, the service can be invoked through the ingress. If false, the service can be invoked only from another Restate service.
       * @default null
       */
      public: boolean | null;
      /**
       * Idempotency retention
       * @description Modify the retention of idempotent requests for this service.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       * @default null
       */
      idempotency_retention: string | null;
      /**
       * Workflow completion retention
       * @description Modify the retention of the workflow completion. This can be modified only for workflow services!
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       * @default null
       */
      workflow_completion_retention: string | null;
      /**
       * Journal retention
       * @description Modify the journal retention for this service. When set, this applies to all requests to all handlers of this service.
       *
       *     In case the invocation has an idempotency key, the `idempotency_retention` caps the maximum `journal_retention` time. In case the invocation targets a workflow handler, the `workflow_completion_retention` caps the maximum `journal_retention` time.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       * @default null
       */
      journal_retention: string | null;
      /**
       * Inactivity timeout
       * @description This timer guards against stalled service/handler invocations. Once it expires, Restate triggers a graceful termination by asking the service invocation to suspend (which preserves intermediate progress).
       *
       *     The 'abort timeout' is used to abort the invocation, in case it doesn't react to the request to suspend.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       *
       *     This overrides the default inactivity timeout set in invoker options.
       * @default null
       */
      inactivity_timeout: string | null;
      /**
       * Abort timeout
       * @description This timer guards against stalled service/handler invocations that are supposed to terminate. The abort timeout is started after the 'inactivity timeout' has expired and the service/handler invocation has been asked to gracefully terminate. Once the timer expires, it will abort the service/handler invocation.
       *
       *     This timer potentially **interrupts** user code. If the user code needs longer to gracefully terminate, then this value needs to be set accordingly.
       *
       *     Can be configured using the [`jiff::fmt::friendly`](https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html) format or ISO8601, for example `5 hours`.
       *
       *     This overrides the default abort timeout set in invoker options.
       * @default null
       */
      abort_timeout: string | null;
    };
    ListServiceHandlersResponse: {
      handlers: components['schemas']['HandlerMetadata'][];
    };
    ModifyServiceStateRequest: {
      /**
       * Version
       * @description If set, the latest version of the state is compared with this value and the operation will fail when the versions differ.
       */
      version?: string | null;
      /**
       * Service key
       * @description To what virtual object key to apply this change
       */
      object_key: string;
      /**
       * New State
       * @description The new state to replace the previous state with
       */
      new_state: {
        [key: string]: number[];
      };
    };
    ListSubscriptionsResponse: {
      subscriptions: components['schemas']['SubscriptionResponse'][];
    };
    SubscriptionResponse: {
      id: components['schemas']['String'];
      source: string;
      sink: string;
      options: {
        [key: string]: string;
      };
    };
    CreateSubscriptionRequest: {
      /**
       * Source
       * @description Source uri. Accepted forms:
       *
       *     * `kafka://<cluster_name>/<topic_name>`, e.g. `kafka://my-cluster/my-topic`
       */
      source: string;
      /**
       * Sink
       * @description Sink uri. Accepted forms:
       *
       *     * `service://<service_name>/<service_name>`, e.g. `service://Counter/count`
       */
      sink: string;
      /**
       * Options
       * @description Additional options to apply to the subscription.
       */
      options?: {
        [key: string]: string;
      } | null;
    };
    VersionInformation: {
      /**
       * Admin server version
       * @description Version of the admin server
       */
      version: string;
      /**
       * Min admin API version
       * Format: uint16
       * @description Minimum supported admin API version by the admin server
       */
      min_admin_api_version: number;
      /**
       * Max admin API version
       * Format: uint16
       * @description Maximum supported admin API version by the admin server
       */
      max_admin_api_version: number;
      /**
       * Ingress endpoint
       * @description Ingress endpoint that the Web UI should use to interact with.
       */
      ingress_endpoint?:
        | components['schemas']['AdvertisedAddress-http-ingress-server']
        | null;
    };
    /**
     * advertised address
     * @description An externally accessible URI address for http-ingress-server. This can be set to unix:restate-data/ingress.sock to advertise the automatically created unix-socket instead of using tcp if needed
     * @example http//127.0.0.1:8080/
     */
    'AdvertisedAddress-http-ingress-server': string;
    VirtualObjectState: string[];
    ListInvocationsRequestBody: {
      filters?: components['schemas']['FilterItem'][];
    };
    BatchInvocationsRequestBody:
      | {
          invocationIds: string[];
          pageSize?: number;
        }
      | {
          filters: components['schemas']['FilterItem'][];
          pageSize?: number;
          /** Format: date-time */
          createdAfter?: string;
        };
    BatchResumeInvocationsRequestBody:
      | {
          invocationIds: string[];
          /**
           * @description Deployment selection strategy: 'keep' uses the current deployment, 'latest' uses the latest deployment
           * @enum {string}
           */
          deployment?: 'keep' | 'latest';
          pageSize?: number;
        }
      | {
          filters: components['schemas']['FilterItem'][];
          pageSize?: number;
          /** Format: date-time */
          createdAfter?: string;
          /**
           * @description Deployment selection strategy: 'keep' uses the current deployment, 'latest' uses the latest deployment
           * @enum {string}
           */
          deployment?: 'keep' | 'latest';
        };
    BatchInvocationsResponse: {
      /** @description Number of successfully processed invocations */
      successful: number;
      /** @description Number of failed processed invocations */
      failed: number;
      /** @description List of invocation IDs that failed to process */
      failedInvocationIds?: string[];
      /** @description Whether there are more pages available (only for filter-based requests) */
      hasMore?: boolean;
      /**
       * Format: date-time
       * @description The created_at timestamp of the last invocation in the current page, used for pagination
       */
      lastCreatedAt?: string;
    };
    ListVirtualObjectStateRequestBody: {
      filters?: components['schemas']['FilterItem'][];
    };
    FilterItem: components['schemas']['FilterBaseItem'] &
      (
        | components['schemas']['FilterNumberItem']
        | components['schemas']['FilterStringItem']
        | components['schemas']['FilterDateItem']
        | components['schemas']['FilterStringListItem']
        | components['schemas']['FilterNullItem']
      );
    FilterBaseItem: {
      /** @enum {string} */
      type: 'STRING' | 'NUMBER' | 'DATE' | 'STRING_LIST' | 'NULL';
      field: string;
    };
    FilterNumberItem: {
      /** @enum {string} */
      type: 'NUMBER';
      /** @enum {string} */
      operation:
        | 'EQUALS'
        | 'NOT_EQUALS'
        | 'GREATER_THAN'
        | 'LESS_THAN'
        | 'GREATER_THAN_OR_EQUAL'
        | 'LESS_THAN_OR_EQUAL';
      value?: number;
    };
    FilterStringItem: {
      /** @enum {string} */
      type: 'STRING';
      /** @enum {string} */
      operation: 'EQUALS' | 'NOT_EQUALS' | 'CONTAINS' | 'NOT_CONTAINS';
      value?: string;
    };
    FilterNullItem: {
      /** @enum {string} */
      type: 'NULL';
      /** @enum {string} */
      operation: 'IS' | 'IS_NOT';
    };
    FilterStringListItem: {
      /** @enum {string} */
      type: 'STRING_LIST';
      /** @enum {string} */
      operation: 'IN' | 'NOT_IN';
      value: string[];
    };
    FilterDateItem: {
      /** @enum {string} */
      type: 'DATE';
      /** @enum {string} */
      operation: 'BEFORE' | 'AFTER';
      /** Format: date-time */
      value: string;
    };
    StateInterfaceResponse: {
      keys?: {
        name: string;
      }[];
    };
    StateResponse: {
      state: {
        name: string;
        value: string;
      }[];
    };
    JournalEntry: components['schemas']['JournalBaseEntry'] &
      (
        | components['schemas']['InputJournalEntryType']
        | components['schemas']['GetStateJournalEntryType']
        | components['schemas']['SetStateJournalEntryType']
        | components['schemas']['GetStateKeysJournalEntryType']
        | components['schemas']['ClearStateJournalEntryType']
        | components['schemas']['ClearAllStateJournalEntryType']
        | components['schemas']['SleepJournalEntryType']
        | components['schemas']['GetPromiseJournalEntryType']
        | components['schemas']['PeekPromiseJournalEntryType']
        | components['schemas']['CompletePromiseJournalEntryType']
        | components['schemas']['OneWayCallJournalEntryType']
        | components['schemas']['CallJournalEntryType']
        | components['schemas']['AwakeableJournalEntryType']
        | components['schemas']['CompleteAwakeableJournalEntryType']
        | components['schemas']['RunJournalEntryType']
        | components['schemas']['CancelInvocationJournalEntryType']
        | components['schemas']['GetCallInvocationIdJournalEntryType']
        | components['schemas']['AttachInvocationJournalEntryType']
        | components['schemas']['GetInvocationOutputJournalEntryType']
        | components['schemas']['CustomJournalEntryType']
        | components['schemas']['OutputJournalEntryType']
        | components['schemas']['CancelSignalJournalEntryType']
      );
    JournalEntryV2: components['schemas']['JournalBaseEntryV2'] &
      (
        | components['schemas']['InputJournalEntryV2']
        | components['schemas']['GetStateJournalEntryV2']
        | components['schemas']['SetStateJournalEntryV2']
        | components['schemas']['GetStateKeysJournalEntryV2']
        | components['schemas']['ClearStateJournalEntryV2']
        | components['schemas']['ClearAllStateJournalEntryV2']
        | components['schemas']['CallJournalEntryV2']
        | components['schemas']['RunJournalEntryV2']
        | components['schemas']['OutputJournalEntryV2']
        | components['schemas']['NotificationCallJournalEntryV2']
        | components['schemas']['NotificationCallInvocationIdJournalEntryV2']
        | components['schemas']['NotificationRunJournalEntryV2']
        | components['schemas']['OneWayCallJournalEntryTypeV2']
        | components['schemas']['SleepJournalEntryTypeV2']
        | components['schemas']['NotificationSleepJournalEntryV2']
        | components['schemas']['CompleteAwakeableJournalEntryV2']
        | components['schemas']['NotificationCompleteAwakeableJournalEntryV2']
        | components['schemas']['AwakeableJournalEntryV2']
        | components['schemas']['AttachInvocationJournalEntryV2']
        | components['schemas']['NotificationAttachInvocationJournalEntryV2']
        | components['schemas']['CancelJournalEntryV2']
        | components['schemas']['NotificationCancelJournalEntryV2']
        | components['schemas']['GetPromiseJournalEntryV2']
        | components['schemas']['PeakPromiseJournalEntryV2']
        | components['schemas']['CompletePromiseJournalEntryV2']
        | components['schemas']['NotificationGetPromiseJournalEntryV2']
        | components['schemas']['NotificationPeakPromiseJournalEntryV2']
        | components['schemas']['NotificationCompletePromiseJournalEntryV2']
        | components['schemas']['TransientErrorJournalEntryV2']
        | components['schemas']['CreatedLifecycleJournalEntryV2']
        | components['schemas']['RunningLifecycleJournalEntryV2']
        | components['schemas']['RetryingLifecycleJournalEntryV2']
        | components['schemas']['ScheduledLifecycleJournalEntryV2']
        | components['schemas']['SuspendedLifecycleJournalEntryV2']
        | components['schemas']['PausedLifecycleJournalEntryV2']
        | components['schemas']['PendingLifecycleJournalEntryV2']
        | components['schemas']['CompletionLifecycleJournalEntryV2']
        | {
            type?: string;
          }
      );
    JournalRawEntry: {
      index: number;
      /** Format: binary */
      raw?: string;
      /** Format: date-time */
      sleep_wakeup_at?: string;
      completed?: boolean;
      promise_name?: string;
      invoked_target?: string;
      invoked_id?: string;
      name?: string;
      event_json?: string;
      entry_json?: string;
      entry_lite_json?: string;
      /** Format: data-time */
      appended_at?: string;
      version?: number;
      event_type?: string;
      /** @enum {string} */
      entry_type:
        | 'Input'
        | 'Output'
        | 'GetState'
        | 'GetEagerState'
        | 'SetState'
        | 'GetStateKeys'
        | 'GetEagerStateKeys'
        | 'ClearState'
        | 'ClearAllState'
        | 'Sleep'
        | 'GetPromise'
        | 'PeekPromise'
        | 'CompletePromise'
        | 'OneWayCall'
        | 'Call'
        | 'Awakeable'
        | 'CompleteAwakeable'
        | 'Run'
        | 'CancelInvocation'
        | 'GetCallInvocationId'
        | 'AttachInvocation'
        | 'GetInvocationOutput'
        | 'Custom'
        | 'Paused'
        | 'Command: Input'
        | 'Command: Output'
        | 'Command: GetState'
        | 'Command: GetEagerState'
        | 'Command: SetState'
        | 'Command: GetStateKeys'
        | 'Command: GetEagerStateKeys'
        | 'Command: ClearState'
        | 'Command: ClearAllState'
        | 'Command: Sleep'
        | 'Command: GetPromise'
        | 'Command: PeekPromise'
        | 'Command: CompletePromise'
        | 'Command: OneWayCall'
        | 'Command: Call'
        | 'Command: Awakeable'
        | 'Command: CompleteAwakeable'
        | 'Command: Run'
        | 'Command: AttachInvocation'
        | 'Command: GetInvocationOutput'
        | 'Command: Custom'
        | 'Command: SendSignal'
        | 'Event'
        | 'Notification: Signal'
        | 'Notification: Sleep'
        | 'Notification: Call'
        | 'Notification: CallInvocationId'
        | 'Notification: AttachInvocation'
        | 'Notification: GetPromise'
        | 'Notification: PeekPromise'
        | 'Notification: CompletePromise'
        | 'Notification: Run';
    };
    JournalBaseEntry: {
      index: number;
      version?: number;
      command_index?: number;
      /** Format: data-time */
      start?: string;
      /** Format: data-time */
      end?: string;
      completed?: boolean;
    };
    JournalBaseEntryV2: {
      isPending?: boolean;
      /** @enum {string} */
      resultType?: 'success' | 'failure' | 'void';
      isRetrying?: boolean;
      isLoaded?: boolean;
      error?: {
        count?: number;
        code?: number;
        message?: string;
        stack?: string;
        restateCode?: string;
      };
      /** Format: datetime */
      start?: string;
      /** Format: datetime */
      end?: string;
      index?: number;
      relatedIndexes?: number[];
      completionId?: number;
      commandIndex?: number;
      /** @enum {string} */
      category?: 'notification' | 'command' | 'event';
      type?: string;
    };
    FailureEntry: {
      message?: string;
      restate_code?: string;
    };
    CancelSignalJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'CancelSignal';
    };
    TransientErrorJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'TransientError';
      stackTrace?: string;
      message?: string;
      code?: number;
      errorCount?: number;
      relatedCommandName?: string;
      relatedCommandType?: string;
      relatedRestateErrorCode?: string;
      relatedCommandIndex?: number;
    };
    CreatedLifecycleJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'Created';
    };
    RunningLifecycleJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'Running';
    };
    RetryingLifecycleJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'Retrying';
    };
    ScheduledLifecycleJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'Scheduled';
    };
    SuspendedLifecycleJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'Suspended';
    };
    PausedLifecycleJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'Paused';
      stackTrace?: string;
      message?: string;
      code?: number;
      relatedCommandName?: string;
      relatedCommandType?: string;
      relatedRestateErrorCode?: string;
      relatedCommandIndex?: number;
    };
    PendingLifecycleJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'Pending';
    };
    CompletionLifecycleJournalEntryV2: {
      /** @enum {string} */
      category?: 'event';
      /** @enum {string} */
      type?: 'Completion';
    };
    InputJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'Input';
      body?: string;
      headers?: {
        key: string;
        value: string;
      }[];
    };
    InputJournalEntryV2: {
      /** @enum {string} */
      category?: 'command';
      /** @enum {string} */
      type?: 'Input';
      handlerName?: string;
      parameters?: string;
      headers?: {
        key: string;
        value: string;
      }[];
    };
    OutputJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'Output';
      body?: string;
      failure?: components['schemas']['FailureEntry'];
    };
    OutputJournalEntryV2: {
      /** @enum {string} */
      type?: 'Output';
      value?: string;
      /** @enum {string} */
      category?: 'command';
    };
    GetStateJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'GetState' | 'GetEagerState';
      key?: string;
      value?: string;
      completed?: boolean;
      failure?: components['schemas']['FailureEntry'];
    };
    GetStateJournalEntryV2: {
      /** @enum {string} */
      type?: 'GetState' | 'GetEagerState';
      key?: string;
      value?: string;
      /** @enum {string} */
      category?: 'command';
    };
    SetStateJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'SetState';
      key?: string;
      value?: string;
    };
    SetStateJournalEntryV2: {
      /** @enum {string} */
      type?: 'SetState';
      key?: string;
      value?: string;
      /** @enum {string} */
      category?: 'command';
    };
    GetStateKeysJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'GetStateKeys' | 'GetEagerStateKeys';
      completed?: boolean;
      keys?: string[];
      failure?: components['schemas']['FailureEntry'];
    };
    GetStateKeysJournalEntryV2: {
      /** @enum {string} */
      type?: 'GetStateKeys' | 'GetEagerStateKeys';
      /** @enum {string} */
      category?: 'command';
      keys?: string[];
    };
    ClearStateJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      key?: string;
      /** @enum {string} */
      entry_type?: 'ClearState';
    };
    ClearStateJournalEntryV2: {
      key?: string;
      /** @enum {string} */
      type?: 'ClearState';
      /** @enum {string} */
      category?: 'command';
    };
    ClearAllStateJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'ClearAllState';
    };
    ClearAllStateJournalEntryV2: {
      /** @enum {string} */
      type?: 'ClearAllState';
      /** @enum {string} */
      category?: 'command';
    };
    SleepJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      completed?: boolean;
      failure?: components['schemas']['FailureEntry'];
      /** Format: data-time */
      sleep_wakeup_at?: string;
      /** @enum {string} */
      entry_type?: 'Sleep';
      name?: string;
    };
    SleepJournalEntryTypeV2: {
      /** Format: data-time */
      wakeupAt?: string;
      /** @enum {string} */
      type?: 'Sleep';
      /** @enum {string} */
      category?: 'command';
      name?: string;
    };
    NotificationSleepJournalEntryV2: {
      /** @enum {string} */
      type?: 'Sleep';
      /** @enum {string} */
      category?: 'notification';
    };
    GetPromiseJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      completed?: boolean;
      /** @enum {string} */
      entry_type?: 'GetPromise';
      promise_name?: string;
      value?: string;
      failure?: components['schemas']['FailureEntry'];
    };
    GetPromiseJournalEntryV2: {
      /** @enum {string} */
      type?: 'GetPromise';
      /** @enum {string} */
      category?: 'command';
      promiseName?: string;
      value?: string;
    };
    PeakPromiseJournalEntryV2: {
      /** @enum {string} */
      type?: 'PeekPromise';
      /** @enum {string} */
      category?: 'command';
      promiseName?: string;
      value?: string;
    };
    CompletePromiseJournalEntryV2: {
      /** @enum {string} */
      type?: 'CompletePromise';
      /** @enum {string} */
      category?: 'command';
      promiseName?: string;
      value?: string;
    };
    NotificationGetPromiseJournalEntryV2: {
      /** @enum {string} */
      type?: 'GetPromise';
      /** @enum {string} */
      category?: 'notification';
      value?: string;
    };
    NotificationPeakPromiseJournalEntryV2: {
      /** @enum {string} */
      type?: 'PeekPromise';
      /** @enum {string} */
      category?: 'notification';
      value?: string;
    };
    NotificationCompletePromiseJournalEntryV2: {
      /** @enum {string} */
      type?: 'CompletePromise';
      /** @enum {string} */
      category?: 'notification';
    };
    PeekPromiseJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      completed?: boolean;
      /** @enum {string} */
      entry_type?: 'PeekPromise';
      promise_name?: string;
      value?: string;
      failure?: components['schemas']['FailureEntry'];
    };
    CompletePromiseJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      completed?: boolean;
      promise_name?: string;
      /** @enum {string} */
      entry_type?: 'CompletePromise';
      completion?: {
        value?: string;
        failure?: components['schemas']['FailureEntry'];
      };
      failure?: components['schemas']['FailureEntry'];
    };
    OneWayCallJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      invoked_id?: string;
      invoked_target?: string;
      key?: string;
      serviceName?: string;
      handlerName?: string;
      parameters?: string;
      headers?: {
        key: string;
        value: string;
      }[];
      /** Format: date-time */
      invokeTime?: string;
      /** @enum {string} */
      entry_type?: 'OneWayCall';
    };
    OneWayCallJournalEntryTypeV2: {
      invocationId?: string;
      serviceKey?: string;
      serviceName?: string;
      handlerName?: string;
      parameters?: string;
      headers?: {
        key: string;
        value: string;
      }[];
      /** Format: date-time */
      invokeTime?: string;
      /** @enum {string} */
      type?: 'OneWayCall';
      /** @enum {string} */
      category?: 'command';
    };
    CallJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      completed?: boolean;
      invoked_id?: string;
      invoked_target?: string;
      failure?: components['schemas']['FailureEntry'];
      key?: string;
      serviceName?: string;
      handlerName?: string;
      parameters?: string;
      headers?: {
        key: string;
        value: string;
      }[];
      value?: string;
      /** @enum {string} */
      entry_type?: 'Call';
    };
    CallJournalEntryV2: {
      invocationId?: string;
      serviceKey?: string;
      serviceName?: string;
      handlerName?: string;
      parameters?: string;
      headers?: {
        key: string;
        value: string;
      }[];
      value?: string;
      /** @enum {string} */
      type?: 'Call';
      /** @enum {string} */
      category?: 'command';
    };
    NotificationCallJournalEntryV2: {
      value?: string;
      /** @enum {string} */
      type?: 'Call';
      /** @enum {string} */
      category?: 'notification';
    };
    NotificationCallInvocationIdJournalEntryV2: {
      value?: string;
      /** @enum {string} */
      type?: 'CallInvocationId';
      /** @enum {string} */
      category?: 'notification';
    };
    NotificationRunJournalEntryV2: {
      value?: string;
      /** @enum {string} */
      type?: 'Run';
      /** @enum {string} */
      category?: 'notification';
    };
    AwakeableJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      completed?: boolean;
      /** @enum {string} */
      entry_type?: 'Awakeable';
      failure?: components['schemas']['FailureEntry'];
      value?: string;
    };
    AwakeableJournalEntryV2: {
      /** @enum {string} */
      type?: 'Awakeable';
      /** @enum {string} */
      category?: 'command';
      value?: string;
      id?: string;
    };
    CompleteAwakeableJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'CompleteAwakeable';
      failure?: components['schemas']['FailureEntry'];
      value?: string;
      id?: string;
    };
    CompleteAwakeableJournalEntryV2: {
      /** @enum {string} */
      type?: 'CompleteAwakeable';
      /** @enum {string} */
      category?: 'command';
      value?: string;
      id?: string;
    };
    NotificationCompleteAwakeableJournalEntryV2: {
      /** @enum {string} */
      type?: 'CompleteAwakeable';
      /** @enum {string} */
      category?: 'notification';
      value?: string;
      id?: string;
    };
    NotificationCancelJournalEntryV2: {
      /** @enum {string} */
      type?: 'Cancel';
      /** @enum {string} */
      category?: 'notification';
    };
    CancelJournalEntryV2: {
      /** @enum {string} */
      type?: 'Cancel';
      /** @enum {string} */
      category?: 'command';
      invocationId?: string;
    };
    CancelInvocationJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'CancelInvocation';
    };
    GetCallInvocationIdJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      completed?: boolean;
      /** @enum {string} */
      entry_type?: 'GetCallInvocationId';
    };
    AttachInvocationJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'AttachInvocation';
      invocationId?: string;
      failure?: components['schemas']['FailureEntry'];
      value?: string;
    };
    AttachInvocationJournalEntryV2: {
      /** @enum {string} */
      type?: 'AttachInvocation';
      /** @enum {string} */
      category?: 'command';
      invocationId?: string;
      value?: string;
    };
    NotificationAttachInvocationJournalEntryV2: {
      /** @enum {string} */
      type?: 'AttachInvocation';
      /** @enum {string} */
      category?: 'notification';
      value?: string;
    };
    GetInvocationOutputJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'GetInvocationOutput';
    };
    CustomJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      /** @enum {string} */
      entry_type?: 'Custom';
    };
    RunJournalEntryType: components['schemas']['JournalBaseEntry'] & {
      name: string;
      /** @enum {string} */
      entry_type?: 'Run';
      failure?: components['schemas']['FailureEntry'];
      value?: string;
    };
    RunJournalEntryV2: {
      name?: string;
      /** @enum {string} */
      type?: 'Run';
      /** @enum {string} */
      category?: 'command';
      value?: string;
    };
    InboxResponse: {
      size?: number;
      head: string;
    } & {
      [key: string]: number;
    };
    Invocation: {
      /** Format: duration */
      completion_retention?: string;
      /** Format: duration */
      journal_retention?: string;
      /** Format: date-time */
      created_at: string;
      /** Format: date-time */
      modified_at: string;
      /** Format: date-time */
      scheduled_at: string;
      /** Format: date-time */
      scheduled_start_at?: string;
      /** Format: date-time */
      inboxed_at?: string;
      /** Format: date-time */
      running_at?: string;
      /** Format: date-time */
      completed_at?: string;
      /** Format: date-time */
      last_start_at?: string;
      /** Format: date-time */
      next_retry_at?: string;
      id: string;
      created_using_restate_version?: string;
      /** @enum {string} */
      invoked_by: 'ingress' | 'service' | 'restart_as_new' | 'subscription';
      restarted_from?: string;
      /** @enum {string} */
      status:
        | 'succeeded'
        | 'failed'
        | 'cancelled'
        | 'killed'
        | 'running'
        | 'suspended'
        | 'scheduled'
        | 'pending'
        | 'ready'
        | 'paused'
        | 'backing-off';
      target: string;
      target_handler_name: string;
      target_service_key?: string;
      target_service_name: string;
      /** @enum {string} */
      target_service_ty: 'service' | 'virtual_object' | 'workflow';
      /** @enum {string} */
      completion_result?: 'success' | 'failure';
      completion_failure?: string;
      invoked_by_service_name?: string;
      invoked_by_subscription_id?: string;
      invoked_by_id?: string;
      invoked_by_target?: string;
      pinned_deployment_id?: string;
      trace_id?: string;
      idempotency_key?: string;
      /** Format: uint32 */
      journal_size?: number;
      /** Format: uint32 */
      pinned_service_protocol_version?: number;
      /** Format: uint32 */
      journal_commands_size?: number;
      /** Format: uint64 */
      retry_count?: number;
      /** Format: uint64 */
      last_failure_related_entry_index?: number;
      last_failure_related_entry_name?: string;
      last_failure_related_entry_type?: string;
      /** Format: uint64 */
      last_failure_related_command_index?: number;
      last_failure_related_command_name?: string;
      last_failure_related_command_type?: string;
      last_attempt_deployment_id?: string;
      last_attempt_server?: string;
      last_failure?: string;
      last_failure_error_code?: string;
      isRetrying?: boolean;
    };
    RawInvocation: {
      /** Format: duration */
      completion_retention?: string;
      /** Format: duration */
      journal_retention?: string;
      /** Format: date-time */
      created_at: string;
      /** Format: date-time */
      modified_at: string;
      /** Format: date-time */
      scheduled_at: string;
      /** Format: date-time */
      inboxed_at?: string;
      /** Format: date-time */
      scheduled_start_at?: string;
      /** Format: date-time */
      running_at?: string;
      /** Format: date-time */
      completed_at?: string;
      /** Format: date-time */
      last_start_at?: string;
      /** Format: date-time */
      next_retry_at?: string;
      id: string;
      /** @enum {string} */
      invoked_by: 'ingress' | 'service' | 'restart_as_new' | 'subscription';
      restarted_from?: string;
      /** @enum {string} */
      status:
        | 'pending'
        | 'scheduled'
        | 'ready'
        | 'running'
        | 'backing-off'
        | 'suspended'
        | 'completed'
        | 'paused';
      target: string;
      target_handler_name: string;
      target_service_key?: string;
      target_service_name: string;
      /** @enum {string} */
      target_service_ty: 'service' | 'virtual_object' | 'workflow';
      /** @enum {string} */
      completion_result?: 'success' | 'failure';
      completion_failure?: string;
      invoked_by_service_name?: string;
      invoked_by_subscription_id?: string;
      invoked_by_id?: string;
      invoked_by_target?: string;
      pinned_deployment_id?: string;
      trace_id?: string;
      idempotency_key?: string;
      /** Format: uint32 */
      journal_size?: number;
      /** Format: uint32 */
      pinned_service_protocol_version?: number;
      /** Format: uint32 */
      journal_commands_size?: number;
      /** Format: uint64 */
      retry_count?: number;
      /** Format: uint64 */
      last_failure_related_command_index?: number;
      last_failure_related_command_name?: string;
      last_failure_related_command_type?: string;
      /** Format: uint64 */
      last_failure_related_entry_index?: number;
      last_failure_related_entry_name?: string;
      last_failure_related_entry_type?: string;
      last_attempt_deployment_id?: string;
      last_attempt_server?: string;
      last_failure?: string;
      last_failure_error_code?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  cluster_health: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterHealthResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  list_deployments: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDeploymentsResponse'];
        };
      };
    };
  };
  create_deployment: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterDeploymentRequest'];
      };
    };
    responses: {
      /** @description Already exists. No change if force = false, overwritten if force = true */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisterDeploymentResponse'];
        };
      };
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisterDeploymentResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_deployment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Deployment identifier */
        deployment: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DetailedDeploymentResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  delete_deployment: {
    parameters: {
      query?: {
        /** @description If true, the deployment will be forcefully deleted. This might break in-flight invocations, use with caution. */
        force?: boolean;
      };
      header?: never;
      path: {
        /** @description Deployment identifier */
        deployment: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Not implemented. Only using the force flag is supported at the moment. */
      501: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  update_deployment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Deployment identifier */
        deployment: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDeploymentRequest'];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DetailedDeploymentResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  health: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  delete_invocation: {
    parameters: {
      query?: {
        /** @description If cancel, it will gracefully terminate the invocation. If kill, it will terminate the invocation with a hard stop. If purge, it will only cleanup the response for completed invocations, and leave unaffected an in-flight invocation. */
        mode?: components['schemas']['DeletionMode'];
      };
      header?: never;
      path: {
        /** @description Invocation identifier. */
        invocation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  cancel_invocation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Invocation identifier. */
        invocation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The invocation has been cancelled. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description The cancellation signal was appended to the journal and will be processed by the SDK. */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      '404 Not Found': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Error when routing the request within restate. */
      '503 Service Unavailable': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      '400 Bad Request': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation was already completed, so it cannot be cancelled nor killed. You can instead purge the invocation, in order for restate to forget it. */
      '409 Conflict': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  kill_invocation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Invocation identifier. */
        invocation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      '404 Not Found': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Error when routing the request within restate. */
      '503 Service Unavailable': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      '400 Bad Request': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation was already completed, so it cannot be cancelled nor killed. You can instead purge the invocation, in order for restate to forget it. */
      '409 Conflict': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  pause_invocation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Invocation identifier. */
        invocation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Already paused */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      '404 Not Found': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Error when routing the request within restate. */
      '503 Service Unavailable': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      '400 Bad Request': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation is not running. An invocation can be paused only when running. */
      '409 Conflict': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  purge_invocation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Invocation identifier. */
        invocation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      '404 Not Found': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Error when routing the request within restate. */
      '503 Service Unavailable': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      '400 Bad Request': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation is not yet completed. An invocation can be purged only when completed. */
      '409 Conflict': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  purge_journal: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Invocation identifier. */
        invocation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      '404 Not Found': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Error when routing the request within restate. */
      '503 Service Unavailable': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      '400 Bad Request': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation is not yet completed. An invocation can be purged only when completed. */
      '409 Conflict': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  restart_as_new_invocation: {
    parameters: {
      query?: {
        /** @description From which entry index the invocation should restart from. By default the invocation restarts from the beginning (equivalent to 'from = 0'), retaining only the input of the original invocation. When greater than 0, the new invocation will copy the old journal prefix up to 'from' included, plus eventual completions for commands in the given prefix. If the journal prefix contains commands that have not been completed, this operation will fail. */
        from?: number;
        /** @description When restarting from journal prefix, provide a deployment id to use to replace the currently pinned deployment id. If 'latest', use the latest deployment id. If 'keep', keeps the pinned deployment id. When not provided, the invocation will resume on latest. Note: this parameter can be used only in combination with 'from'. */
        deployment?: string;
      };
      header?: never;
      path: {
        /** @description Invocation identifier. */
        invocation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RestartAsNewInvocationResponse'];
        };
      };
      '404 Not Found': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Error when routing the request within restate. */
      '503 Service Unavailable': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description
       *     The given journal index is out of range.
       *     The given journal prefix contains some Commands without respective Completions.
       *     The given deployment was not found.
       *     The selected deployment id to restart as new the invocation doesn't support the currently pinned service protocol version. */
      '400 Bad Request': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation is still running. An invocation can be restarted only when completed.
       *     The invocation is still running or the deployment id is not pinned yet, deployment id cannot be changed. The deployment id can be changed only if the invocation is paused or suspended, and a deployment id is already pinned. */
      '409 Conflict': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Restarting the invocation is not supported. Restarting workflows is not supported, and restarting invocations created using the old service protocol. */
      '422 Unprocessable Entity': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation cannot be restarted because the input is not available. In order to restart an invocation, the journal must be available in order to read the input again. Journal can be retained after completion by enabling journal retention. */
      '410 Gone': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation cannot be restarted because it's not running yet, meaning it might have been scheduled or inboxed. */
      '425 Too Early': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  resume_invocation: {
    parameters: {
      query?: {
        /** @description When resuming from paused/suspended, provide a deployment id to use to replace the currently pinned deployment id. If 'latest', use the latest deployment id. If 'keep', keeps the pinned deployment id. When not provided, the invocation will resume on the pinned deployment id. When provided and the invocation is either running, or no deployment is pinned, this operation will fail. */
        deployment?: string;
      };
      header?: never;
      path: {
        /** @description Invocation identifier. */
        invocation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      '404 Not Found': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description Error when routing the request within restate. */
      '503 Service Unavailable': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description
       *     The given deployment was not found.
       *     The selected deployment id to resume the invocation doesn't support the currently pinned service protocol version. */
      '400 Bad Request': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation is either inboxed or scheduled. An invocation can be resumed only when running, paused or suspended. */
      '425 Too Early': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      /** @description The invocation is completed. An invocation can be resumed only when running, paused or suspended.
       *     The invocation is still running or the deployment id is not pinned yet, deployment id cannot be changed. The deployment id can be changed only if the invocation is paused or suspended, and a deployment id is already pinned. */
      '409 Conflict': {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  openapi_spec: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            [key: string]: string;
          };
        };
      };
    };
  };
  list_services: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListServicesResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_service: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Fully qualified service name. */
        service: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServiceMetadata'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  modify_service: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Fully qualified service name. */
        service: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ModifyServiceRequest'];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServiceMetadata'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  list_service_handlers: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Fully qualified service name. */
        service: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListServiceHandlersResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_service_handler: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Fully qualified service name. */
        service: string;
        /** @description Handler name. */
        handler: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HandlerMetadata'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_service_openapi: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Fully qualified service name. */
        service: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OpenAPI 3.1 of the service */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  modify_service_state: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Fully qualified service name. */
        service: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ModifyServiceStateRequest'];
      };
    };
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  list_subscriptions: {
    parameters: {
      query?: {
        /** @description Filter by the exact specified sink. */
        sink?: string;
        /** @description Filter by the exact specified source. */
        source?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSubscriptionsResponse'];
        };
      };
    };
  };
  create_subscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSubscriptionRequest'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_subscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Subscription identifier */
        subscription: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  delete_subscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Subscription identifier */
        subscription: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  version: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionInformation'];
        };
      };
    };
  };
  query: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          query: string;
        };
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            rows?: {
              [key: string]: string;
            }[];
          };
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  list_invocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListInvocationsRequestBody'];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            rows: components['schemas']['Invocation'][];
            total_count: number;
            total_count_lower_bound?: boolean;
            limit?: number;
          };
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  count_invocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListInvocationsRequestBody'];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            count: number;
          };
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  batch_cancel_invocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchInvocationsRequestBody'];
      };
    };
    responses: {
      /** @description Batch cancellation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchInvocationsResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  batch_purge_invocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchInvocationsRequestBody'];
      };
    };
    responses: {
      /** @description Batch purge result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchInvocationsResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  batch_kill_invocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchInvocationsRequestBody'];
      };
    };
    responses: {
      /** @description Batch kill result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchInvocationsResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  batch_pause_invocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchInvocationsRequestBody'];
      };
    };
    responses: {
      /** @description Batch pause result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchInvocationsResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  batch_resume_invocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchResumeInvocationsRequestBody'];
      };
    };
    responses: {
      /** @description Batch resume result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchInvocationsResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_invocation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Invocation id */
        invocationId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Invocation'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_invocation_journal: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Invocation id */
        invocationId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            entries: components['schemas']['JournalEntry'][];
          };
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_journal_entry: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Invocation id */
        invocationId: string;
        /** @description Entry index */
        entryIndex: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JournalEntryV2'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_invocation_journal_v2: {
    parameters: {
      query?: {
        /** @description Should include journal */
        journal?: boolean;
      };
      header?: never;
      path: {
        /** @description Invocation id */
        invocationId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Invocation'] & {
            journal?: {
              version?: number;
              entries?: components['schemas']['JournalEntryV2'][];
            };
          };
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_inbox: {
    parameters: {
      query?: {
        /** @description Invocation id */
        invocationId?: string;
      };
      header?: never;
      path: {
        /** @description service name */
        name: string;
        /** @description key */
        key: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InboxResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_state_keys: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description service name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StateInterfaceResponse'];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  list_virtual_object_state: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description service name */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          keys: string[];
        };
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            objects: (components['schemas']['StateResponse'] & {
              key: string;
            })[];
          };
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  get_state: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description service name */
        name: string;
        /** @description key */
        key: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': WithRequired<
            components['schemas']['StateResponse'],
            'state'
          > & {
            version?: string;
          };
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
  query_virtual_object_state: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description service name */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVirtualObjectStateRequestBody'];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            keys: string[];
          };
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDescriptionResponse'];
        };
      };
    };
  };
}
type WithRequired<T, K extends keyof T> = T & {
  [P in K]-?: T[P];
};
